[{"title":"Unity网络游戏开发(3)","date":"2022-11-16T07:38:12.000Z","url":"/2022/11/16/Unity%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/Unity%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91-3/","tags":[["网络游戏","/tags/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F/"],["unity","/tags/unity/"]],"categories":[["Unity网络游戏开发","/categories/Unity%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"]],"content":"Unity网络游戏开发第三部分 第五章 深入了解TCP5.1 TCP的连接、传输和终止我们都听说过三次握手，四次挥手的表述，但是很难理解为什么要三次握手四次挥手。 要理解这点，我们首先要理解到TCP是一种面向连接的，可靠的，基于字节流的传输层协议，像连接这种事为了确保可靠一定要保证双方的网络是相通的。 先来看三次握手： 主角： 主机一和主机二 过程：主机一向主机二发送请求连接的报文，由于网络环境差，致使此报文一直呆在网络环境中，最终导致失效，主机一或许早已完成连接，或许放弃了连接，反正此时不打算和主机二连接了，此时这个报文到达了主机二，主机二以为是主机一发的，假设只是两次握手，主机二向主机一发出确认报文问，但是主机一并没有打算连接，所以丢弃，但是主机二还以为连上了苦苦的在那里等，这就导致了资源的浪费。所以需要三次握手。 本人理解:一个面向连接的协议自然要保证连接的双向连通，两次握手，主机一知道了主机一到主机二的道路和主机二到主机一的道路都是通的，但是主机二只知道主机一到主机二的道路是通的，不知道主机二到主机一的道路是通的。除非主机一发送确认报文，并且主机二清楚的收到。（有点绕，可以多看几遍） 再来看看四次挥手： 主机一向主机二请求断开连接，代表着主机一并没有数据往主机二发了，但是不代表主机二没有数据往主机一发了，所以主机一你先别急，等主机二发完了，向主机一再发送请求断开连接，主机一再处理完主机二发来的剩余信息后才发送确认信息，然后主机一释放连接，主机二也释放连接。 5.2 常用的TCP参数Socket相当于TCP与UDP提供的接口，所以我们可以通过Socket获取或修改TCP的很多参数 ，这有利于我们构造更为实用的框架。 5.3 Close的恰当的时机在TCP参数中的LingerState能够尽量发完操作系统缓冲区的信息，但是不要忘了我们之前写的发送方法，我们在发送前会将消息放入自己设置的缓冲区，这些数据在关闭的时候就会丢失。 解决方法是设置一个bool值判断是否正在Closing，主动关闭的一方如果还有要发送的消息就将isClosing设置为true，关闭前就判断isClosing为true就不能关闭，如果为false就能发送。 5.4 心跳机制如果玩游戏一半，网线被噶了，那就没机会发送FIN信号了，如果不处理的话，服务端就一直占着系统资源，TCP有一个检测机制，如果在指定的时间没有数据传送就会发送一个信号，对端如果收到信号就会返回确认信号，如果一段时间没有收到回应就会重试几次，如果都没有，会认为网络不通关闭Socket。 启用方法： 但是TCP提供的方法不太适用于游戏，因为网游强调一个高实时性。 所以一般会自己实现心跳机制，客户端会定时向服务端发出PING消息，服务端收到回应PONG消息，若是很久没收到就说明连接不通，释放资源。 第六章 帧同步和状态同步6.1 状态同步状态同步指的是同步状态信息，比如角色需要做出的动作，角色的位置坐标、旋转发送给服务端，服务端再做广播。这种同步方式会将核心的逻辑判断交给服务端，否则就会导致延迟过高。举个例子： 如果服务端只是作为一个转发器，那么当一个玩家同步自己释放技能的状态，很有可能网络原因导致其他主机很晚才收到，这就会导致延迟很高，而如果只是将释放技能这个状态同步给服务端，服务端收到后进行一定程度的判断和运算再将处理后的状态同步给所有的玩家，这样再一定程度上保持了所有玩家是同步的，但是这也会导致响应慢等问题。所以状态同步一般不会适用于实时度比较高的pvp游戏。 6.1.1 跟随算法上述是服务端处理完再广播的方式，还有一种方法就是服务端还是当个转发工具人，网络不好的情况下势必会导致经常瞬移，所以聪明的程序大佬们想到了一个方法，就是如果获得了一个状态与客户端的状态有差距就以一定的速度将物体达到这个状态，只要同步频率够高误差就可以忽略，但是如果我们仔细分析一下，这个相对于直接状态同步误差更大，于是人们又引用了预测算法。 6.1.2 预测算法在某些有规律可循的条件下比如坦克的匀速运动，或者匀加速运动，我们可以预测坦克接下来的位置，我们就让坦克提前走到预测的位置去，但是这也会引发一个问题，就是玩家控制的东西一般来说没啥规律，所以如果玩家再运行途中停了下来，就会看到一个神奇的现象，一个往前开的坦克又默默的退了回来，而且预测算法也比较复杂。 两种算法各有优势，具体情况具体分析。 6.2 帧同步在游戏中同步的是玩家的操作指令，操作指令包含当前的帧索引。一般的流程是客户端上传操作到服务器， 服务器收到后并不计算游戏行为， 而是转发到所有客户端。帧同步其实是指令同步的一种。 6.2.1 指令同步玩家只同步指令信息，相同的输入 + 相同的时机 &#x3D; 相同的输出。 6.2.2 同步帧帧同步的帧与unity中的帧是两个概念，在unity中我们说Update函数每一帧调用一次，我们也说Update调用的快慢取决于使用的设备，那如果某个设备Update慢点就没法保证相同的时机了，这些偏差会导致整个游戏不同的客户端差距巨大，所以我们会另外引入一个叫同步帧的概念。帧同步的特性导致客户端的逻辑实现和表现实现必须完全分离。Unity中的一些方法接口(如 Invoke， Update、动画系统等)是不可靠的，所有要自己实现一套物理引擎、数学库，做到逻辑和表现分离。 这样即使Unity的渲染是不同步的，但是逻辑跑出来是同步的。 6.3 帧同步与状态同步对比"},{"title":"Unity网络游戏开发(2)","date":"2022-11-16T07:23:53.000Z","url":"/2022/11/16/Unity%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/Unity%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91-2/","tags":[["网络游戏","/tags/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F/"],["unity","/tags/unity/"]],"categories":[["Unity网络游戏开发","/categories/Unity%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"]],"content":"Unity网络游戏开发第二部分 第四章 正确收发数据流第四章和第五章会涉及到一些TCP的一些机制 4.1 TCP数据流我们都听说过一句话TCP是一种流模式协议，UDP是一种数据报模式的协议。 TCP的流模式指的就是发送的数据如同水流一样发送方将数据发送出去时操作系统会将数据放在发送缓存中，然后接收方在接收前也会先将数据放入接收缓存中，而读取的速度取决于设备和操作系统，这也就意味着发送的次数与接收的次数并不一定相同。你发送的数据量不能大于对方的接收缓存（流量控制），如果你硬是要发送过量数据，则对方的缓存满了就会把多出的数据丢弃。 UDP和TCP不同，发送端调用了几次write，接收端必须用相同次数的read读完。UDP是基于报文的，在接收的时候，每次最多只能读取一个报文，报文和报文是不会合并的，如果缓冲区小于报文长度，则多出的部分会被丢弃。 4.2 粘包与半包基于TCP的流模式就会导致一个比较关键的问题，如果客户端在极短的时间内发送多个数据，就会导致接收的时候将两段代码合并在一起导致解析错误之类的问题。 我们看一下大乱斗游戏的一段代码。 这里我用了一个协程让程序等0.1秒之后再请求服务器上其他玩家的数据，为什么呢？我们把他改成连续发送会怎样呢？ 我们先看看协程方式下服务端收到的消息 再将程序改成连续发送 可以看到服务端将连续两次发的消息合成了一句消息，导致了服务端程序无法解析，导致程序报错并退出，如果正在运营的网游出现这种情况导致服务器停机，这样会造成很大的损失。 这个现象被称为粘包现象，那么半包现象也好理解了，运气较差的话操作系统将一半的指令读取了，这样也会给服务端造成比较那一处理的麻烦。 一般有三种方法可以解决粘包与半包问题： 4.2.1 长度信息法这个方法是在每个数据包前加上长度信息，比如传输hello就变成5hello，一个字节最多表示255个字节，稍微有点少，所以一般会选择Int16或者Int32来表示数据长度，这样再服务端处理的时候就可以先放进一个缓冲区，通过程序保证每一次都能拿到对应的发送信息。 4.2.2 固定长度法规定每条信息的长度，如果一条信息短于这个规定长度则用规定的字符将信息填充到这个固定长度，比如规定长度为10，我要发送hello，规定用.来补全，就变成了hello…..了。 4.2.3 结束符号法规定某个不会使用的符号作为结束符号，这样只需要检测到这个符号，就把这个符号之前的信息切出来，保证服务端接收的次数和客户端发送的次数一致。 书上采用的是长度信息法。 4.3 大端小端问题使用长度信息法的话我们需要将代表长度的Int16或者Int32转化成byte数组发送出去，到了接收方肯定需要再转化成Int类型这个时候会用到一下两个方法： 而这两句可能会导致大端小端问题 4.3.1 什么是大端小端学过计组的可能有了解，不同的CPU使用了不同的存储方式，这是由于一些历史的因素导致的。 大端：高地址存低字节，低地址存高字节 小端：低地址存低字节，高地址存高字节 例如： 这是一个16位的内存，我们将他转化位一个Int16类型的数 如果是个大端的系统那么高地址存低字节，高地址的00000010会转化为2，低地址的存高字节，低地址的00000001会转化成256，整个数据会转化为256+2&#x3D;258。 如果是个小端的系统那么高地址存高字节，高地址的00000010会转化为512，低地址存低字节，低地址的00000001会转化成1，整个数据会转化成512+1&#x3D;513。 所以同样的一串二进制数在不同的系统中会解析成不同的数字，非常的不方便。 4.3.2 如何解决大端小端的问题既然计算机本身不能解决问题，那么我们就用程序来解决问题，我们首先规定数据的传输必须使用小端输入，因为我们必须使用小端编码，所以我们需要判断系统是否是小端，如果不是小端，那么我们就使用Reverse函数来转化成小端模式。 一下是发送数据的大致代码 拓展: 虽然BitConverter.IsLittleEndian可以直接调用并判断计算机的大小端，但是我们也应该学习一下如何去实现判断大小端的方法，我分别用C#，C++，C三种语言实现一下： C++： C++使用了union的特点来测试：不懂union可以去查一下 C： C++完全兼容C，所以也可以用这种方法 拓展结束 发送端的代码搞定了，但是如果接收端是大端的话BitConverter.ToInt16也会出问题，所以我们要自己解析接收到的代码： 这段代码理解起来可能稍微有点难理解，首先我们先将第二个字节向左移动八位，也就是乘了一个256然后与第一个字节相与，这在二进制中代表的是相加。最后再强转成Int16类型的数值。 4.4 不完整发送之前介绍到TCP在发送时会先将需要发送的数据先放入操作系统的缓冲区，如果操作系统缓冲区设计的比较小，在网络环境较差的环境下，导致操作系统的缓冲区满了，这个时候再发送，溢出的部分会被抛弃掉引发不完整发送，虽然再网络通畅的环境下，Send只发送部分数据的改率不高，很多商业游戏都没有处理这种情况，但是我们要知道这种情况如何去处理。 4.4.1 解决方案要让数据能够完整发送，最好的方法就是将这个数据在发送前保存起来，如果发生不完整发送，在回调函数中继续发送数据。 代码实现： 解析以上这段代码，首先我们定义了自己的缓冲区，缓冲区偏移量，缓冲区的剩余长度。然后分别赋值，调用BeginSend，发送完成调用回调函数，将偏移量加上已发送数据，定位到发送到哪了，将剩下的长度减去发送的长度，用于判断是否发完，没发完继续调用BeginSend继续发送。 这种方法已经解决了大部分的问题，但是如果我们在还没来的及调用回调函数发出剩下的数据时又再次调用了Send，那么sendBytes，length，readIdx都会被重置，该发不完还是发不完（你这不是什么都没解决嘛），为此我们有必要牺牲一点点内存来构造一个加强版的缓冲区。我们将设计一个缓冲队列，每一次发送新的消息都将新消息写入队列的末尾，等前面的消息读取完，就将前面的消息弹出队列，开始读取后面的消息。 补充：如果你有过开发动作游戏的经验的话，你就会发现很多设计都有一曲同工之妙，比如你处理玩家的一系列指令的话，也可以将这些指令先放入一个队列，程序再一个一个调用。而且如果有什么特殊攻击的话也可以通过此判断。 我们来看看实现的代码： 队列我们直接使用Queue 看一下如何使用呢： ​ 这样的程序看似已经非常完善了，但是我们依旧忽略了一个问题，这是个异步方法，回调函数和BeginSend运行于不同的线程，不同的线程操作同一段内存一定要注意一个问题，那就是线程冲突，设想一种情况：我们先发一条消息，这个消息放进了队列，此时开始运行Send，这个时候Send函数又被调用，将另一条消息放入队列这个时候回调函数刚还执行完并将第一条消息发送出去，再次调用了BeginSend，将第二条消息发送出去了，原线程也在此时调用了BeginSend，于是一条消息发送了两次。 画个图理解以下 学过操作系统的都明白这中情况怎么处理，简单来说就是加锁： 4.5 高效接收数据既然要追求极致那就贯彻到底，接收数据我们也可以使用之前定义的ByteArray 首先我们要解决两个问题 1.能读写信息 2.缓冲区不够长时自动扩张缓冲区 那么我们就来完善以下ByteArray代码： 使用方法： 这里就不多做介绍了，具体的内容和实现可以多看看代码"},{"title":"Unity网络游戏开发(1)","date":"2022-11-16T06:19:47.000Z","url":"/2022/11/16/Unity%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/Unity%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91-1/","tags":[["网络游戏","/tags/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F/"],["unity","/tags/unity/"]],"categories":[["Unity网络游戏开发","/categories/Unity%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"]],"content":"近几年大量的网络游戏大热，相较于单机多了更多的趣味，且手游越来越火热，所以网络游戏开发势必成为一个客户端程序员的基本素养，不仅要了解客户端的搭建，还要熟悉服务端的基本实现方式。 本系列专栏作为Unity3D网络游戏实战的笔记总结 第一章 网络游戏的开端1.1 服务端一款网络游戏分为客户端服务端两个部分，客户端在用户设备上运行，服务端则在游戏运营商的服务器上运行。服务端与客户端之间通常使用TCP网络通信，各个服务端之间互相使用TCP连接，形成服务端集群。 1.2 Socket我们都知道计算机网络七层模型和五层模型，那在学习的时候常用的五层模型来说，分为物理层，数据链路层，网络层，传输层，应用层，我们也知道传输层实现端到端的通信主要的两个协议：TCP协议、UDP协议，这两个协议的区别与实现请自行去学习计算机网络这门课，我们今天要介绍的是Socket。可能有人和我当时有一样的疑问，这个Socket是应用层的还是传输层的，经过我的查阅，这个Socket应该和TCP、UDP一样属于传输层，我们可以把它理解为TCP、UDP协议的封装，以及对外提供的接口。 那么它其中都包含了什么呢？ ​ 1.协议（TCP，UDP） ​ 2.本地IP地址 ​ 3.本地端口 ​ 4.远程IP地址 ​ 5.远程端口 每一条Socket连接代表着：本地Socket→本地端口→网络介质→远程端口→远程Socket 的链路。 为了方便之后的使用，我们先了解一下Socket通信的完整流程（TCP协议） ​ 1.创建一个Socket对象（使用API Socket），绑定本地使用的端口，服务端一定要在程序中指定端口进行绑定（使用API Bind），而客户端在连接（使用API Connect）时会由系统分配端口，可以省去绑定步骤 ​ 2.服务端开启监听（使用API Listen），等待客户端接入 ​ 3.客户端连接服务器（使用API Connect） ​ 4.服务端接收连接（使用API Accept） ​ 5.客户端与服务端通过Send和Receive等API收发数据 ​ 6.某一方关闭连接（使用API Close），结束通信 第二章 异步API2.1 API如果使用上述API会因为是同步程序导致在网络环境稍差的情况下会造成客户端卡顿，所以同步API一般只用于早期测试，真正开发的时候会尽量使用异步API，虽然异步API不是那么容易理解，但是他能使客户端更加流畅。 而这些API基本都是上面描述的API前面加上Begin前缀，比如Connect的异步调用就是BeginConnect。 所有的异步API参数中都有一个委托，这个委托需要放入一个回调函数，以达到异步的效果。 2.2 非异步方式解决程序卡顿问题异步很好，而且在实际的游戏开发中也会更多的使用异步API来实现网络编程。 但是同时也有其他的一些API也能够达到类似的目的。也就是Poll、Select的API。 2.2.1 PollPoll的作用就是判断某个Socket是否可读可写可用，调用方式为 microSeconds：等待回应的时间，-1为一直等待，0表示不阻塞 mode： SelectMode.SelectRead：是否可读 SelectMode.SelectWrite：是否可写 SelectMode.SelectError：是否可用 Poll的服务端的核心代码为： Poll简单来说就是一个一个检测是否有可读信息，有就处理，这样就能避免明明没有可用的消息还是将程序阻塞在哪里，导致卡顿，但是由于没有数据的时候也还是需要检测数据，同样也还是浪费，且导致CPU占用率过高。 2.2.2 SelectSelect相对Poll来说实现了多路复用，即同时检测多个Socket状态，调用方式为： 前三个参数分别对应三个列表，第四个参数为等待回应时间 Select服务端的核心代码： Select与Poll其实很相近，只是Poll是一个一个处理，导致其频繁的调用造成CPU占用率高，但是Select集中去处理，调用次数少CPU占用率就会稍微低一点，但是两个方法都是使用一个死循环循环的去执行，在客户端中也是在Update函数里面不停检测，所以商业上为了达到性能的极致通常还是会选用异步。 第三章 大乱斗游戏本游戏的原代码 服务端 客户端"}]