[{"title":"数据结构笔记","date":"2022-12-25T06:19:47.000Z","url":"/2022/12/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/","tags":[["数据结构","/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"],["算法","/tags/%E7%AE%97%E6%B3%95/"]],"categories":[["数据结构笔记","/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/"]],"content":"本笔记是我大一的时候自学数据结构所总结的笔记。内容不多，深度也比较低，想对数据结构进行精进的大可不必看这个，如果只是为了应付学校的考试或者入个门，这个倒是足够了。 当时也是刚接触到md，所以有些地方写的不太好，请谅解 第一章：数据结构绪论逻辑结构与物理结构逻辑结构逻辑结构：是指数据对象中数据元素之间的相互关系面向问题的。 逻辑结构可以分为四类。 集合结构即数据除了在同一集合中无其他关系。 线性结构数据元素之间是一对一关系 树形结构数据元素之间呈现一对多关系 图形结构数据元素之间呈现多对多关系 物理结构线性存储数据均放在连续的存储空间中。可以进行随机访问。链式存储 链式存储把数据存储在任意存储单元，各个数据的关系通过指针来表示 第二章：算法概念说白了就是解决问题办法 特性基本的输入输出有穷性指算法在执行有限的步骤之后，自动结束而不会出现无线循环，并且每一个步骤在可接受范围内完成 确定性算法每一步都具有确定的定义，不能同一种情况进入不同的分支 可行性算法的每一步都必须可行 设计要求正确性算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性，能正确反应问题的需求、能够的到问题的正确答案 本人翻译：就是算法算出来的必须是对的 健壮性当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名奇妙的结果 本人翻译：就是当用户点一份蛋炒饭时程序不会炸 可读性算法设计的另一目的是为了便于月的、理解和交流 本人翻译：说白了就是要让人能看懂 时间效率高和存储量低本人翻译：跑程序时电脑不卡，跑的快，又不占内存 算法优劣的判断方法时间复杂度 时间复杂度所需消耗的时间即基本操作执行次数 时间复杂度的计算该方法就是大O阶表示法的计算方法 （1）用常数 1取代运行时间中的所有加法常数 （2）在修改后的运行次数函数中，只保留最高阶项 （3）如果最高阶项存在且不是 1，则去除与这个项相乘的常数 常用时间复杂度的比较 空间复杂度运行完一个程序所需内存的大小 注：感觉用得不多，目前了解定义就行 第三章：线性表定义零个或多个数据元素的有限序列 线性表的顺序存储结构定义用一段连续得存储空间对数据进行存储 本人翻译：说白了就是数组 特性拥有随机访问特性 时间复杂度(1)对于存取操作 线性表的顺序存储结构，对于存取操作，其时间复杂度为O(1) 因为元素位置可以直接计算得到 (2)对于插入和删除操作 对于插入和删除操作，其时间复杂度为O(n)因为插入或删除后，需要移动其余元素 使用场景因此，线性表顺序存储结构比较适用于元素存取操作较多，增删操作较少的场景 线性表的链式存储结构定义一个或多个结点组合而成的数据结构称为链表 结点结点一般由两部分组成 数据域用来装需要存储的数据 指针域存储指向下一个结点的指针 头结点为了能更加方便地对链表进行操作，会在单链表的第一个结点（即头指针）前附设一个结点，称为 头结点 该结点不装任何实际数据方便操作 注：并非每个链表都有 头指针指向第一个结点的指针称之为头指针 注：不一定是头指针 单链表单链表的时间复杂度（1）存取操作 而对于单链表结构，假设需要获取第 i 个元素，则必须从第一个结点开始依次进行遍历，直到达到第 i 个结点。因此，对于单链表结构而言，其数据元素读取的时间复杂度为O(n) 注：你需要从第一个开始一个一个去找，而不是通过下标一下子找到，所以时间复杂度为O(n) （2）插入删除 对其任意一个位置进行增删操作，其时间复杂度为O(n) 注：之所以还为O(n)主要原因是你需要找到所需插入的元素 链式表与顺序表的优缺点缺点链式表存取操作的时间复杂度更高 优点虽然插入删除两种时间复杂度都为都为O(n)，但是如果需要插入删除，顺序表由于每次插入删除都要移动其他元素，所以每次都为O(n)，而链式表第一次插入时查找到所需要的位置，之后的插入删除操作仅需要修改一下指针，所以之后的插入删除操作的时间复杂度为O(1) 链式表与顺序表的选择经常进行存取操作时，可选择顺序表 经常进行插删操作时，可选择链式表 循环链表定义将单链表中的终端结点的指针端由空指针改为指向头结点就使整个单链表形成一个环这种头尾相接的单链表称为单循环链表，简称 循环链表 个人翻译：就是把链表最后的结点的下一个结点指向第一个结点 注：头结点的作用是判断首尾，并非每一个循环链表都需要头结点 作用循环链表要好使用需要设置一个尾指针指向循环链表的最后一个结点，这样便可以使寻找尾结点的时间复杂度调为O(1),并且寻找头结点也只需要移动到下一个或下下个结点，时间复杂度也为O(1) 双向链表定义在单链表的每个结点中，再设置一个指向其前驱结点的指针域 双向循环链表既然单链表有循环链表，那双向链表自然有双向循环链表 双向循环链表重点双向循环链表最重要的是在插入删除时的操作顺序 插入时： 删除时： 删除时记得要将删除的结点释放 第四章：栈与队列栈定义栈是限定仅在表尾进行插入和删除操作的线性表 个人翻译：看过弹夹吗，他只会在装弹口进行装弹和弹出操作，这就是栈 允许插入删除操作的一端为栈顶，另一端为栈底 栈的插入操作称为入栈 栈的删除操作称为出栈 不含任何任何数据元素的栈称为 空栈 特性栈最显著的特性就是先进后出 栈的分类顺序栈可以使用线性表的顺序存储结构（即数组）实现栈，将之称之为顺序栈 所有顺序存储的结构都有一个很致命的问题就是需要事先确定一个固定的长度，固定长度所导致的问题就是内存空间的浪费或是内存的溢出 同样的他们也都有一个优势就是存取定位非常方便 链式栈可以使用单链表实现栈，称之为链式栈 所有链式存储的结构也都有一个很致命的问题就是在每一个数据结点中都需要增加一个指针域，这会增加内存的开销，但好处是栈的长度一般来说是无限的 时间复杂度由于插入操作皆是在队尾进行，所以当有一个指针一直指在队尾时无论是顺序表还是链式表时间复杂度都为O(1) 栈的应用四则运算方法： 一、首先通过栈将中缀表达式转化为后缀表达式 规则： 数字直接加入后缀表达式 如果是‘(’, 入栈 如果是‘)’, 则依次把栈中的运算符加入后缀表达式，直到出现‘(’并从栈中删除它 如果是运算符 + - * / a.栈空或者栈顶元素为‘(’, 入栈 b.高于栈顶元素优先级，入栈 c.否则依次弹出栈顶运算符，直到遇到一个优先级小于它的运算符或者是遇到‘(’为止 遍历完成后，如果栈非空则依次弹出所有栈顶元素加入到表达式当中 二、通过栈得到运算结果 从左到右,遇到运算符就弹出相应的运算数,运算后再把结果入栈.最终结果就是栈顶数的值. 队列定义队列是允许在一端进行插入操作，而在另一端进行删除操作的线性表。 允许删除的一端称为队头 允许插入的一端称为队尾 特性队列是先进先出 队列分类顺序队列 链式队列 循环队列顺序队列会造成一个问题，就是假溢出，队头元素出栈后，并不能像顺序表一样，将剩下的元素集体往前面移一个地址，就会造成，队列前面明明有大量的空间未被使用但是元素排到队尾造成假溢出，为了解决这个问题就引入了循环链表的概念。 定义将头尾相接的顺序存储结构称为循环队列 当头尾相接时虽然解决了假溢出的问题，但是同样也产生了一个问题，无法判断队列是否已满。 判断队列是否已满的方法第一种设置一个标志变量，当front==rear，且flag=0时为队列空 当front==rear，且flag=1时为队列满 第二种当队列空时，front==rear，当队列满时，我们修改它的条件，保留一个元素空间。也就是说，队列满是，数组中还有一个空闲单元。 所以循环队列求队伍长度（rear-front+maxsize）%maxsize通过这个公式也可判定队列是否满了 第五章：串定义串是由零个或多个字符组成的有限序列，又名字符串 串中的字符数目称为串的长度 零个字符的串称为空串 分类串与线性表很像，只是限定了串中的元素必须为字符 故字符串的分类与线性表是一样的 串分为顺序存储结构以及链式存储结构 注：这章有个模式匹配算法，比较复杂，有机会的话再总结成一篇 第六章：树定义树是n个结点的有限集 n=0时称为空树 注：个人感觉这个定义啥也没说，所以要判断一个东西是不是树，应该用下面的特点进行判断 特点有且仅有一个特定的称为根的结点 当n&gt;1时，其余结点可分为m（m&gt;0）个 互不相交的有限集，其中的每一个集合本身又是一颗树，并且称为根的子树 基本术语结点拥有的子树数称为结点的度 度为0的结点称为叶节点或终端结点 个人翻译：该结点下面没有其他结点了，这个结点就是终端结点 度不为0的结点就是非终端节点或分支节点 除根节点以外的分支结点称为内部结点 树的度就是内部结点中度的最大值 结点之间的关系结点的子树的根称为该结点的孩子，该节点称为孩子的双亲。 个人翻译：与某个结点相连的结点中，在这个结点上面的就是该结点的双亲，在这个结点下面的就是这个结点的孩子 同一个双亲的孩子互相之间互称兄弟 结点的祖先是从根到该节点所经分支上的所有节点 以某节点为根的子树中的任一结点都称为该节点的子孙 树的层次 有序树如果将树中的结点的各子树看成从左至右是有次序的，不能互换的，则称该树为有序树，否则称为无序树 森林森林时m颗互不相交的树的集合 二叉树（重点）定义二叉树是n个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两颗互不相交的，分别称为根结点的左子树和右子树的二叉树组成 个人翻译：除了空集这个比较特殊的二叉树，如果看到一颗树它的所有结点的子节点最多只有两个，那这个树就是二叉树 特点 每个结点最多只能有两棵子树 左子树和右子树是有顺序的，次序不能任意颠倒 即使树中某结点只有一棵子树，也要区分它是左子树还是右子树 特殊二叉树满二叉树定义：只含度为0和2的结点且度为0的结点只出现在最后一层的二叉树称为满二叉树 完全二叉树定义：对任意一颗满二叉树，从它的最后一层的最右结点起，按从下到上、从右到左的次序去掉若干个结点后所得到的二叉树称为完全二叉树 特性1.在二叉树的第i层上至多有$2^{i-1}$个结点 2.深度为k的二叉树至多有$2^k-1$个结点 3.对任何一颗二叉树T，如果其叶子结点点数为$n_0$，度（即子结点数)为 2 的结点数为$n_1$，则$n_0=n_1+1$ 4.具有n个结点的**完全二叉树**的深度$[log2n]+1$ 注：$[x]$表示不大于x的最大整数 5.如果对一棵树有n个结点的完全二叉树（其深度为$[log2n]+1$的结点按层次编号，从左到右，对任一结点i有 a.如果i=1，则该结点为根结点，无双亲，若i&gt;1，则其双亲为i/2 b.如果2i&gt;n，则节点i无左孩子（结点i为叶子节点），否则其左孩子为2i c.如果结点2i+1&gt;n，则节点i无右孩子，否则其右结点为2i+1 二叉树的遍历二叉树遍历均有两种比较实用的算法：一种为递归算法，一种则是非递归的算法 先序遍历如果二叉树为空，则进行空操作，否则进行以下操作： 1.访问根节点 2.先序遍历左子树 3.先序遍历右子树 递归算法： 思路：运用递归的思想，如果左子树不为空就一直访问左子树，直到左子树为空，左子树为空则会回到上一次递归，访问右子树，以右子树为根结点继续优先访问左子树，直到左子树为空，又跳出本次递归，然后一层一层的解递归，就能最终将整颗二叉树访问完毕。 非递归算法： 思路：非递归算法需要用到之前所学到的线性表的栈，整体思路则是将根结点放入栈中，访问左节点，将左节点放入栈中，只要左节点不为空则一直访问左节点，并将它放入栈中，当左节点为空则访问这个节点的右结点，并将该节点放入栈中，然后继续访问右结点的左节点，然后将右结点放入栈中，直到访问到叶子节点，则取出栈头元素，访问其右结点 中序遍历1.中序遍历所有左子树 2.访问根节点 3.中序遍历所有右子树 两种算法思路与先序遍历基本一致，此处不再赘述，只提供相应代码 递归算法： 非递归算法： 后序遍历1.后序遍历左节点 2.后序遍历右结点 3.访问根节点 递归算法： 非递归算法： 层次遍历二叉树的层次遍历就是按照二叉树的层次，从上到下，从左到右依次遍历，为了实现这种遍历方式则需要用到之前所学到的队列 思路：首先将根节点放入队列，然后出队，访问根节点，将根节点的左孩子右孩子依次放入队列中，再依次从队列中取出各个结点，重复刚才的操作，直到队列为空。 线索二叉树由于二叉树中有些节点或是左节点为空，或是右结点为空，或是都为空，会导致二叉树对内存的浪费，于是提出了线索二叉树的概念。 定义利用这些空链域存放在某种遍历次序下该结点的前驱结点和后继结点的指针，这些指针称为线索，加上线索的二叉树称为线索二叉树。 事实上如果只是为了应付考试，只需要知道线索二叉树怎么画就行了 线索二叉树的画法重要规则如果一个结点的左孩子为空，则指向它的前驱结点。 如果一个结点右孩子为空，则指向它的后继。 举个例子 假设要画这个二叉树的中序二叉树 先写出它中序遍历的结果：DFBACE 然后画出每个结点的结构 注：结点名字左右两边的数字作为标志，该节点如果有左孩子，左标志为0，否则为1，右孩子亦然 接下来通过重要规则以及中序遍历结果连线就完事了 树，森林，二叉树转换我自己是看的这篇文章，写的真不错啊（主要我懒得画图）  哈夫曼树以及哈夫曼编码这位大佬通过举例子的方式讲的哈夫曼树以及哈夫曼编码，仔细看很容易看懂（懒得画图，开摆了）  第七章：图定义由顶点的有穷非空集合和顶点之间的边的集合组成。 个人翻译:点之间连着线就是图 数据结构间的区别线性表：一对一，只有前驱和后驱 树：一对多，一个结点对应多个子节点，一个根节点 图：多对多，多个顶点对应多个顶点 图的分类无向图若顶点$v_i$到$v_j$之间的边没有方向，那么这条边就是无向边 如果图中任意两个结点之间的边都是无向边，则称为无向图 无向图顶点的边数叫做顶点的度 有向图若从顶点$v_i$到$v_j$的边有方向，则称这条边为有向边，也称为弧 如果图中任意两个顶点之间的边都是有向边，则称该图为 有向图 指向自己的边的条数称为顶点的入度，由自己指出去的边的条数称为出度 简单图在图中，若不存在顶点到其自身的边，且同一条边不重复出现，则称这样的图为简单图 无向完全图在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图 有向完全图在有向图中，如果任意两个顶点之间都存在 方向互为相反 的两条弧，则称该图为有向完全图 权有些图的边或弧具有相应的权值，这种与图的边有关的数被称为权 带权的图一般被称之为网 个人翻译：好比两个点之间有路，路就是图的边，而距离就是这条边的权 连通图图中顶点间存在路径，两顶点存在路径则说明是连通的 没有重复顶点的路径称为简单路径 无向如果无向图中任意两个结点是连通的，则称之为连通图 有向有向连通图分为弱连通，单向连通，强连通 弱连通：有向图的底图（无向图）是连通图，则是弱连通图 单向连通：有向图中，任意两个结点至少有一个到另一个是可达的，则是单向连通图 强连通：有向图中，任意两个结点互相可达，则该图为强连通图 图的存储结构计算机只认识01，所以我们不可能在cpu上面画一个图然后逼着cpu完成运算 于是便有了图的存储结构，和线性表一样，图的存储结构也分为两种分别是：邻接矩阵，邻接表 邻接矩阵图的邻接矩阵存储方式是用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组(称为邻接矩阵)存储图中的边或弧的信息。 邻接表用单链表和顺序存储的方式来存放图 这个存储结构比较复杂，我觉得我会讲错，所以摆烂了，想要学习的可以去看看这位大佬的  图的遍历图的遍历也是有两种方法，分别是深度优先遍历，广度优先遍历 深度优先遍历由名字可得优先向前访问 首先以一个未被访问过的顶点作为起始顶点沿当前顶点的边走到未访问过的顶点 当没有未访问过的顶点时则回到上一个顶点继续试探别的顶点，直至所有的顶点都被访问过 广度优先遍历同样由名字可得优先对一个结点指向的其他所有未被访问的结点进行遍历 依次将访问到的顶点放入队列，然后依次访问他们的下一个结点，访问到的均放入队列 直到队列为空，整个图访问结束 可以用来解最短路径问题 最小生成树最小生成树包含两种算法，分别是普利姆算法和克鲁斯卡尔算法，由于我实在懒的画图所以也粘一篇大佬的文章了  拓扑排序这个很简单，只要按着以下步骤走就没问题 1.寻找未被指向的结点，将他取出（若有多个选其一） 2.去除取出的结点和与它相连的线 3.执行第一步 4.直到整个图都完成排序"},{"title":"C#知识(9)","date":"2022-12-24T15:29:46.000Z","url":"/2022/12/24/CS%E7%9F%A5%E8%AF%86/CS%E7%9F%A5%E8%AF%86-9/","tags":[["C#","/tags/C/"]],"categories":[["C#知识","/categories/C-%E7%9F%A5%E8%AF%86/"]],"content":"本节主要内容：协程及Unity中的用法 1.协程（1）使用本章的内容将紧扣unity中的协程进行讲解，先来看看一个协程应该怎么使用。 上面的就是协程的使用方式。 （2）优点然后我们来聊一聊协程的好处，在搜资料的时候我看到一个有趣的例子，你去某个办事处办事，此时办事处是cpu每个人办的事就是一个一个线程，办事处只有一个员工（对应cpu在同一个时间只能进行一个线程），当这个员工要从一件事转头去做另一件事，自然要做许多事，比如先暂停上一件事，然后把上一件事资料整理好，方便下次做这件事的时候开始，然后要加载另一件事所需的资源，所以线程之间的切换是很耗费时间的，但是，如果你自己能仿制办事处的办事方法，就不需要再到办事处浪费时间了，这就是协程的好处。 让原来要使用异步 + 回调方式写的非人类代码, 可以用看似同步的方式写出来。能够分步做一个比较耗时的事情，如果需要大量的计算，将计算放到一个随时间进行的协程来处理，能分散计算压力 （3）缺点我们可以看到我们上面的程序，需要再返回时new一个对象，如果再程序中大量的创造对象会引发GC，同时，如果激活的协程较多，就可能会造成多个协程挤在同一帧执行，导致卡顿。 （4）协程的运行时间 所有使用到yield的都是协程，协程不是线程，和update和start一样在主线程上运行。 （5）协程结束方式1.StopCoroutine，不解释，上面有用法，别用错了 2.stopAllCoroutines暂停的是当前脚本下的所有协程 3.移除脚本，移除物体，禁用物体（实测禁用脚本屁用没有） （6）中断函数类型null 在下一帧所有的Update()函数调用过之后执行 WaitForSeconds() 等待指定秒数，在该帧（延迟过后的那一帧）所有update()函数调用完后执行。即等待给定时间周期， 受Time.timeScale影响，当Time.timeScale = 0f 时，yield return new WaitForSecond(x) 将不会满足。 WaitForFixedUpdate 等待一个固定帧，即等待物理周期循环结束后执行 WaitForEndOfFrame 等待帧结束，即等待渲染周期循环结束后执行 StartCoroutine 等待一个新协程暂停 WWW 等待一个加载完成，等待www的网络请求完成后，isDone=true后执行 （7）执行顺序开始协程-&gt;执行协程-&gt;遇到中断指令中断协程-&gt;返回上层函数继续执行上层函数的下一行代码-&gt;中断指令结束后，继续执行中断指令之后的代码-&gt;协程结束 协程如果还有问题可以看看:，我就是看这篇文章总结出来的。"},{"title":"C#知识(8)","date":"2022-12-24T15:29:43.000Z","url":"/2022/12/24/CS%E7%9F%A5%E8%AF%86/CS%E7%9F%A5%E8%AF%86-8/","tags":[["C#","/tags/C/"]],"categories":[["C#知识","/categories/C-%E7%9F%A5%E8%AF%86/"]],"content":"本节主要内容：垃圾回收机制和相关重要算法 本章内容大量参考： 1.GC（垃圾回收机制）当我们进行C++的开发的时候，我们有时需要使用new关键词在堆上手动开辟空间，同时也会用到delete来进行空间的释放，在C里面则是使用malloc和free关键词，但是当我们使用C#时我们大部分时候并不需要去管理堆上的内存，就好像系统帮我们完成了开辟和回收。 其实C#作为一门托管型语言，托管代码在clr中运行，clr会自动惊醒垃圾回收等服务，所以我们才可以放心的随便创建引用值而不用担心内存遗漏。接下来简单介绍以下GC的机制。 （1）标志压缩算法该算法分三个步骤： 1.先假设堆中所有对象都可以回收 2.然后找出不能回收的对象 3.最后堆中没有打标记的对象都是可以被回收的 4.此时堆中对象不连续，移动这些对象，使他们重新从基地址开始连续 经过这四步处理后，可以继续采用前面的堆内存分配方法，即仅用一个指针记录堆分配的起始地址就可以。 主要处理步骤：将线程挂起→确定不能回收的对象→对象回收→堆压缩→指针修复。 此处有两个问题： 1.怎么确定哪些对象不能回收？ 答：首先GC从已经初始化的静态变量或者线程人在使用的对象（stack+CPU register）确定roots，通过复杂的引用关系，从roots出发开始寻找，如果能通过相互引用到达的引用则标记为不能回收的对象，剩余的对象则可以回收。 2.指针修复干了什么？ 答：我们知道引用对象的存储方式是在栈上存储一个引用，这个引用其实就类似一根指针，他指向堆中相对应的内存，而当我们回收完并对堆进行压缩后，这些指针之前指的就会变成错误的地址，所以要进行修复。 Debug和release执行模式之间稍有区别，release模式下后续代码没有引用的对象是可以回收的，而debug模式下需要等到当前函数执行完毕，这些对象才会成为可回收的，目的是为了调试时跟踪局部对象的内容。 一些问题：Pinned objects指分配之后不能移动位置的对象，例如传递给非托管代码的对象（或者使用了fixed关键字），GC在指针修复时无法修改非托管代码中的引用指针，因此将这些对象移动将发生异常。pinned objects会导致堆出现碎片，但大部分情况来说传给非托管代码的对象应当在GC时能够被回收掉。 （2）分代算法程序可能使用几百M、几G的内存，对这样的内存区域进行GC操作成本很高，分代算法是基于一定的统计学基础，对GC的性能进行了改善。通过对象的生命周期讲对象分成了新对象和老对象也就是分了代，分代算法的假设前提 1.新创建的对象生命周期都比较短，而较老的对象生命周期会更长 2.对部分内存进行回收比基于全部内存的回收操作要快 3.新创建的对象之间关联程度通常较强。堆分配的对象是连续的，关联度较强有利于提高CPU cache的命中率 于是我们把堆分为了3代，分别是Gen0、Gen1、Gen2 如果Gen 0 heap内存达到阀值，则触发0代GC，0代GC后Gen 0中幸存的对象进入Gen1。如果Gen 1的内存达到阀值，则进行1代GC，1代GC将Gen 0 heap和Gen 1 heap一起进行回收，幸存的对象进入Gen2。如图： 2代GC将Gen 0 heap、Gen 1 heap和Gen 2 heap一起回收，Gen 0和Gen 1比较小，这两个代龄加起来总是保持在16M左右；Gen2的大小由应用程序确定，可能达到几G，因此0代和1代GC的成本非常低，2代GC称为full GC，通常成本很高。粗略的计算0代和1代GC应当能在几毫秒到几十毫秒之间完成，Gen 2 heap比较大时，full GC可能需要花费几秒时间。大致上来讲.NET应用运行期间，2代、1代和0代GC的频率应当大致为1:10:100。 （3）几个较为重要的垃圾回收相关apiGC.Collect()：这个的立足点是整个程序，调用这个程序会强制执行一次垃圾回收。也就是像上文提到的那样。 虚构函数：和C++的定义方法相同，它的立足点是类，一个类对象在被垃圾回收时会执行虚构函数中的内容。 Dispose()和close()：也是基于某个类对象，但是这个类对象是有非托管对象的类，GC不会处理非托管对象的释放，所以需要手动调用，有些类对象的是Dispose，而有些是close，但是实现的功能是一样的。如果你自己需要定义自己的Dispose()函数需要实现 IDisposable接口。 注：使用using语句可以自动调用Dispose()函数。 （4）Finalization Queue和Freachable Queue看到这个标题可能有点懵，但是我们可以提取关键词，queue一眼队列，这两个队列并不用于存储真正的对象，而是存储一组指向对象的指针。当程序中使用了new操作符在Managed Heap上分配空间时，GC会对其进行分析，如果该对象含有Finalize方法则在Finalization Queue中添加一个指向该对象的指针。 在GC被启动以后，经过Mark阶段分辨出哪些是垃圾。再在垃圾中搜索，如果发现垃圾中有被Finalization Queue中的指针所指向的对象，则将这个对象从垃圾中分离出来，并将指向它的指针移动到Freachable Queue中。这个过程被称为是对象的复生（Resurrection），本来死去的对象就这样被救活了。为什么要救活它呢？因为这个对象的Finalize方法还没有被执行，所以不能让它死去。Freachable Queue平时不做什么事，但是一旦里面被添加了指针之后，它就会去触发所指对象的Finalize方法执行，之后将这个指针从队列中剔除，这是对象就可以安静的死去了。"},{"title":"C#知识(7)","date":"2022-12-24T15:29:39.000Z","url":"/2022/12/24/CS%E7%9F%A5%E8%AF%86/CS%E7%9F%A5%E8%AF%86-7/","tags":[["C#","/tags/C/"]],"categories":[["C#知识","/categories/C-%E7%9F%A5%E8%AF%86/"]],"content":"本节主要内容：泛型相关知识 1.泛型泛型要会，但是面试稍微考的较少。 C++有泛型，那我C#自然也有，相对于C++的泛型，C#的泛型显得更为简洁，老规矩，实践出真知，来点泛型实例： 输出： 整个代码理解起来应该不难，其中包含了泛型的基本使用方法， 其中还有一些泛型的优点，但我们先不谈，先看看泛型怎么声明的，包括方法，委托，类，接口等 泛型特点看看我们最初的程序的输出。有个数字实在太突出了，对于值类型Int32没有使用泛型而是使用Object类型来接收数据的ArrayList，不断地添加和取出都会造成装箱和拆箱，而众所周知，装箱和拆箱都十分地花时间，这就是用泛型地一个优点，当不知到之后地编程人员会传入什么类型时，它舍弃了以Object为接收类型，而是让后面地编程人员自己定义。剩下地特点用菜鸟教程地总结来稍微拉一下。 它有助于您最大限度地重用代码、保护类型的安全以及提高性能。 您可以创建泛型集合类。.NET 框架类库在 System.Collections.Generic 命名空间中包含了一些新的泛型集合类。您可以使用这些泛型集合类来替代 System.Collections 中的集合类。 您可以创建自己的泛型接口、泛型类、泛型方法、泛型事件和泛型委托。 您可以对泛型类进行约束以访问特定数据类型的方法。 关于泛型数据类型中使用的类型的信息可在运行时通过使用反射获取。 泛型约束泛型约束地作用是确保泛型类使用的参数是提供特定方法的类型。 稍微举个例子作为演示，具体地可以去微软官方看 微软官网对于泛型约束的定义网址："},{"title":"C#知识(6)","date":"2022-12-24T15:29:37.000Z","url":"/2022/12/24/CS%E7%9F%A5%E8%AF%86/CS%E7%9F%A5%E8%AF%86-6/","tags":[["C#","/tags/C/"]],"categories":[["C#知识","/categories/C-%E7%9F%A5%E8%AF%86/"]],"content":"本节主要内容：反射相关知识 1.反射反射指的是System.Reflection的这个命名空间，官方对这个命名空间的作用介绍是：包含通过检查托管代码中程序集、模块、成员、参数和其他实体的元数据来检索其相关信息的类型。 这些类型还可用于操作加载类型的实例，例如挂钩事件或调用方法。其实这就是反射的基本作用。 用途： 它允许在运行时查看特性（attribute）信息。 它允许审查集合中的各种类型，以及实例化这些类型。 它允许延迟绑定的方法和属性（property）。 它允许在运行时创建新类型，然后使用这些类型执行一些任务。 优缺点优点： 1、反射提高了程序的灵活性和扩展性。 2、降低耦合性，提高自适应能力。 3、它允许程序创建和控制任何类的对象，无需提前硬编码目标类。 缺点： 1、性能问题：使用反射基本上是一种解释操作，用于字段和方法接入时要远慢于直接代码。因此反射机制主要应用在对灵活性和拓展性要求很高的系统框架上，普通程序不建议使用。 2、使用反射会模糊程序内部逻辑；程序员希望在源代码中看到程序的逻辑，反射却绕过了源代码的技术，因而会带来维护的问题，反射代码比相应的直接代码更复杂。 （来自菜鸟教程：） 其实简单理解一下主要核心就是使用Type类（这个类派生自MemberInfo，而Member Info所属命名空间为System.Reflection）的API。 反射的使用要使用Type类的api，那首先就要获取到某个东西的Type类型。这里用一个类来举例。 可以用typeof或用你想获取类型的东西调用它内部的GetType()，我在看文献的时候其实看到过另外一种方法： 但是我测试的时候会报出异常，不知道为什么，所以就不用了，毕竟前两个完全足够了。 Type类的属性 Name数据类型名 FullName 数据类型的完全限定名(包括命名空间名) Namespace 定义数据类型的命名空间名 IsAbstract 指示该类型是否是抽象类型 IsArray 指示该类型是否是数组 IsClass 指示该类型是否是类 IsEnum 指示该类型是否是枚举 IsInterface 指示该类型是否是接口 IsPublic 指示该类型是否是公有的 IsSealed 指示该类型是否是密封类 IsValueType 指示该类型是否是值类型 BaseType 获取父类的类型 Type类的方法 GetConstructor(), GetConstructors()：返回ConstructorInfo类型，用于取得该类的构造函数的信息 GetEvent(), GetEvents()：返回EventInfo类型，用于取得该类的事件的信息 GetField(), GetFields()：返回FieldInfo类型，用于取得该类的字段（成员变量）的信息 GetInterface(), GetInterfaces()：返回InterfaceInfo类型，用于取得该类实现的接口的信息 GetMember(), GetMembers()：返回MemberInfo类型，用于取得该类的所有成员的信息 GetMethod(), GetMethods()：返回MethodInfo类型，用于取得该类的方法的信息 GetProperty(), GetProperties()：返回PropertyInfo类型，用于取得该类的属性的信息 这些api多去试试就能熟练使用，我就不演示了。 BindingFlags在使用GetMethods()可能会遇到一个问题，Methods 中只包含 public 权限的成员方法，而 public 权限的属性器也被当做两个 Method 了。 GetMethods 除了获取了类中的方法，也获取了父类中的方法。那能不能回去private权限的成员方法呢，又能不能不获取父类方法呢？ 当然没问题，这里就要用到BindingFlags。 它的本体是个枚举类型，具体可以去微软官网查一下具体的字段方便使用。 这就是反射需要大致掌握的知识，一定要记住一点，反射对性能开销很大，少用。"},{"title":"C#知识(5)","date":"2022-12-24T15:29:35.000Z","url":"/2022/12/24/CS%E7%9F%A5%E8%AF%86/CS%E7%9F%A5%E8%AF%86-5/","tags":[["C#","/tags/C/"]],"categories":[["C#知识","/categories/C-%E7%9F%A5%E8%AF%86/"]],"content":"本节主要内容：事件相关知识 1.事件上一篇讲了委托，这篇讲事件，事件这玩意我自己又没怎么用过，不过没关系，因为这玩意能干的事委托都能干，事实上他其实就是在委托上面加了一些限制来确保委托不会被滥用，至于它的相关知识，了解用法即可，因为用的确实不多。 事件的声明：声明事件之前一定要声明委托类型，或者用C#自带的委托类型如Action&lt;&gt;之类的。三个类，我们把它分别叫做发布器类（prog），订阅类（A），触发类（progMain），使用方法基本上就是这样了。稍微了解以下编译器如何实现事件。 C#编译器编译时把它转换为一个私有的委托和两个方法，两个方法是为了提供登记对某个事件的方法（用+=的时候）和注销对某个事件的关注的方法（用-=的时候）。因为提供的委托是私有类型的，所以事件相较于委托有个非常大的区别，event 只能在所声明的类的内部调用，但是在别的类中可以进行 += 和 -= 操作。 本来想讲讲反射的但是反射有点多，所以只能留到下章了。"},{"title":"C#知识(4)","date":"2022-12-24T15:29:32.000Z","url":"/2022/12/24/CS%E7%9F%A5%E8%AF%86/CS%E7%9F%A5%E8%AF%86-4/","tags":[["C#","/tags/C/"]],"categories":[["C#知识","/categories/C-%E7%9F%A5%E8%AF%86/"]],"content":"本节主要内容：委托相关知识 1.委托本来我是想先聊聊事件的，但是没有委托的事件是不完整的，所以我们还是先聊一下委托， 如果你和我一样是C++和C#双开的，你一定知道C++里面有一个概念叫做指针，而指针中有一类比较特殊的叫做函数指针，函数指针的作用其实就是让一个函数变成一个变量，让函数变成方法的参数，从而指定方法根据不同情况使用不同函数。 其实C#中委托和函数指针的作用几乎一模一样，，又或者说就是一样的。先来看一下用法吧。 委托的使用非常简单，声明的时候使用一个delegate关键词就行。使用的话可以把实例出来的委托名直接作为函数名使用。也可作为参数传给其他的方法。 接下来我们讨论以下委托的深层次的东西（来源于《clr via C#》） 使用起来简答的东西内部的实现细节就会越复杂，为了让委托好用，编译器和clr为我们干了太多事了（感动）（如果不知到clr是什么的，我回头会写，你可以先当它是C#虚拟机） 当我们用以下语句定义一个委托时 编译器会将这行代码定义成下面这样一个类 BeginInvoke和EndInvoke先不谈，先聊一下构造器和Invoke函数 构造器，其实就是C++的构造函数，我们首先注意到的是它的两个参数，既然构造函数有参数，自然是要用这些函数来初始化类中的成员的，所有的委托都是继承于System.MulticastDelegate这个类，而System.MulticastDelegate这个类又是派生自System.Delegate类，这其中有一些历史原因，这里就不展开说了，反正就是继承下来的成员有三个比较重要的： 所以构造器的两个参数分别是target，methodPtr。 最后一个字段invocationList则是在我们像allshow那样将一堆方法构造成一个委托链时会用到，他就像一个链表分别去装构造这个委托的所有方法或委托。 接下来是Invoke方法，这个方法在委托被定义的时候被定义,通过调用target和methodPtr字段在指定的对象上调用包装好的回调方法。所以通过委托调用方法时，其实就是在调用委托类的Invoke方法，所以你直接在编程的时候就直接写成a.Invoke(s)也可以。 最后就是在System.Delegate类中有个方法可以直接取得invocationList中的值。比如下面这个例子就是其中的一种用法。 "},{"title":"C#知识(3)","date":"2022-12-24T15:27:43.000Z","url":"/2022/12/24/CS%E7%9F%A5%E8%AF%86/CS%E7%9F%A5%E8%AF%86-3/","tags":[["C#","/tags/C/"]],"categories":[["C#知识","/categories/C-%E7%9F%A5%E8%AF%86/"]],"content":"本节主要内容：属性、成员和字段的区别，接口相关知识 1.属性、成员和字段的区别字段一般在类内部使用，所以一般是private属性。 属性一般是供外部访问，所以一般是public属性。 成员则是包括属性，字段，方法，事件等。 2.接口接口与其叫接口不如叫约束，他规定了一个东西是什么，而派生类则定义了怎么做 接口中可以声明属性（是属性，不是成员，也不是字段），方法和事件，接口只负责声明，定义由派生类实现。 接口的实现有两种方式，分别是隐式实现和显式实现 1.隐式实现接口的大部分实现都是靠隐式实现 2.显示实现显式实现是为了解决实现多个接口时有可能出现的重名问题。 为了解决重名的问题，需要使用到向上转型 3.接口其他细节 实现接口的任何类型或结构都必须实现器所有的成员 接口类似于只有抽象成员的抽象基类。 实现接口的任何类或结构都必须实现其所有成员。 接口无法直接进行实例化。 其成员由实现接口的任何类或结构来实现。 接口可以包含事件、索引器、方法和属性。 接口不包含方法的实现。 一个类或结构可以实现多个接口。 一个类可以继承一个基类，还可实现一个或多个接口。 "},{"title":"C#知识(2)","date":"2022-12-24T15:16:39.000Z","url":"/2022/12/24/CS%E7%9F%A5%E8%AF%86/CS%E7%9F%A5%E8%AF%86-2/","tags":[["C#","/tags/C/"]],"categories":[["C#知识","/categories/C-%E7%9F%A5%E8%AF%86/"]],"content":"本节主要内容：Partial关键字，结构体struct 1.partial关键字paritial 可以实现类的逻辑拆分到不同的文件。 上面的代码虽然是在不同的文件中，但是在同一个项目中同时定义了两个相同的名字是一定会报错的。 但是当我门使用partial关键字来限定类后则不会报错 运行输出结果： 2.结构体C#中的结构体的定义和C++别无二致，并且声明的方式也是相同的，都是类似与以下的代码： 但是我查了一些资料，发现这两个语言的结构体其实差距还是蛮大的 1.C++ struct首先是C++的结构体，C++的结构体和类几乎没有任何区别，他包含类有的所有特性，不仅能包含变量，也能继承，实现多态甚至类可以继承于结构体，结构体也能继承于类，说实话，我看到这的时候人都傻了，既然结构体和类这么像，为啥还要结构体，我认为是为了兼容c语言的语法吧。而在C++中结构体与类的主要区别就仅仅体现在两个方面： 1.默认的继承访问权限，结构体默认是public继承，class是private的。 2.成员变量的默认访问权限，结构体默认是public，class是private。 2.C# structC#的结构体也没有C的那么单纯，他也能带有方法字段，同时他还能带有索引、属性、运算符方法和事件，大概有以下特点： 结构可带有方法、字段、索引、属性、运算符方法和事件。 结构可定义构造函数，但不能定义析构函数。但是，您不能为结构定义无参构造函数。无参构造函数(默认)是自动定义的，且不能被改变。 与类不同，结构不能继承其他的结构或类。 结构不能作为其他结构或类的基础结构。 结构可实现一个或多个接口。 结构成员不能指定为 abstract、virtual 或 protected。 当您使用 New 操作符创建一个结构对象时，会调用适当的构造函数来创建结构。与类不同，结构可以不使用 New 操作符即可被实例化。 如果不使用 New 操作符，只有在所有的字段都被初始化之后，字段才被赋值，对象才被使用。 结构体中声明的字段，除非将字段声明为 const 或 static，否则无法赋予初值。 赋值时是深拷贝 在为属性器时，不能局部赋值（比如 transofrm.position.x 不能直接赋值） 结构体相比类，内存的回收效率更高，不容易产生 gc，所以需要频繁创建的数据对象建议用结构体来实现，比如 Unity 的 Vector3/2 等。 还有一点需要提醒，C#结构体的默认访问权限是private 其次结构体作为值类型在栈上分配内存存储，至于如果在结构体内有引用类型，那栈中就保存这个引用类型分配在堆的地址，值类型在用完由clr回收机制自动回收，对于结构体中的引用类型，回收的时候只回收用于存储地址的内存，而用于存储引用类型成员变量值的内存，则等待回收机制进行回收。"},{"title":"C#知识(1)","date":"2022-12-24T12:52:38.000Z","url":"/2022/12/24/CS%E7%9F%A5%E8%AF%86/CS%E7%9F%A5%E8%AF%86-1/","tags":[["C#","/tags/C/"]],"categories":[["C#知识","/categories/C-%E7%9F%A5%E8%AF%86/"]],"content":"本节主要内容：引用类型与值类型，程序集和类的访问权限，internal。 1.引用类型、值类型C#中有两种类型：分别是引用类型和值类型 在C#中值类型的变量直接存储数据，而引用类型的变量持有的是数据的引用，数据存储在数据堆中。 图上忘写了，数组也是引用类型 这里顺便提一下C++和C#在内存管理上的区别，C#是一种托管语言，它的垃圾回收机制时由.net平台负责，但是我们还是有必要了解这方面的。 先是C#，程序运行时可能会有多个线程，每个线程在创建时都会生成一个线程栈，值类型的值会直接在线程栈上进行存储，而引用类型的值则会先在堆上开辟一块空间，在栈上存储这块控件的地址 然后是C++,C++编译程序占用内存分为以下几个部分， 1.栈区（stack）：— 由编译器自动分配释放 ，存放函数参数值，局部变量值等。其操作方式类似于数据结构中栈。 2.堆区（heap）：一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中堆是两回事，分配方式类似于链表。 3.全局区（静态区）：全局变量和静态变量存储是放在一块，初始化全局变量和静态变量在一块区域， 未初始化全局变量和未初始化静态变量在相邻另一块区域。 程序结束后由系统释放。 4.文字常量区 —常量字符串就是放在这里。 程序结束后由系统释放 5.程序代码区—存放函数体二进制代码。 栈上的内存自动分配了，暂且不聊，这个堆区则是由程序员来分配释放的，C的话是使用malloc分配，free释放，C++则是用new和delete。 重要：值类型在内存管理方面具有更好的效率，并且不支持多态，适合用做存储数据的载体；引用类型支持多态，适合用于定义应用程序的行为。 值得注意的是，引用类型和值类型都继承自System.Object类。不同的是，几乎所有的引用类型都直接从System.Object继承，而值类型则继承其子类，即直接继承System.ValueType。即System.ValueType本身是一个类类型，而不是值类型。其关键在于ValueType重写了Equals()方法，从而对值类型按照实例的值来比较，而不是引用地址来比较。 2.程序集和类的访问权限internal程序集是一个或多个类型的一文件及资源文件的集合（感觉和文件夹差不多）。 Microsoft引入这个概念的目的是可以将代码分成多个文件，如果客户端永远使用不到这多程序可以永远不将这段程序加载到客户端上。 然后internal这个类访问权限以前我也完全没听说过，也是最近在看《clr via C#》这本书才了解到这个访问权限，它所修饰的类只能在同一个程序集中被访问，而同一个程序集表示同一个dll程序集或同一个exe程序集。 有人可能会注意到dll这个词，当时我读到这也挺疑惑的，因为我之前曾经读过《深入理解计算机系统》，这书提到过动态链接库这样一个概念，而动态链接库在windows中的后缀也是dll。 接下来演示以下unity中如何使用程序集 首先先说明一下使用程序集在unity的优点吧。 1.提高编译速度：unity将用户定义的C#文件默认放进Assembly-Csharp.dll程序集中，每当编写或修改完代码时，unity需要编译整个程序集的代码，来判断是否编译错误。使用多个程序集就能解决这个问题。 2.减少项目的耦合度：不用多解释，和设计模式思路一样，而且可以快速判断代码出在哪一个程序集中的文件。通过程序集的依赖，来联系各个程序集。 方法： 1.在一个空的文件夹中右键，选择Create，选择Assembly Definition，在再这个文件夹中创建的文件将自动划入创建的程序集中 2.在程序集的inspector面板上的Assembly Definition References添加需要依赖的类，则可以完成程序集的依赖设置。 "},{"title":"Unity网络游戏开发(3)","date":"2022-11-16T07:38:12.000Z","url":"/2022/11/16/Unity%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/Unity%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91-3/","tags":[["网络游戏","/tags/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F/"],["unity","/tags/unity/"]],"categories":[["Unity网络游戏开发","/categories/Unity%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"]],"content":"Unity网络游戏开发第三部分 第五章 深入了解TCP5.1 TCP的连接、传输和终止我们都听说过三次握手，四次挥手的表述，但是很难理解为什么要三次握手四次挥手。 要理解这点，我们首先要理解到TCP是一种面向连接的，可靠的，基于字节流的传输层协议，像连接这种事为了确保可靠一定要保证双方的网络是相通的。 先来看三次握手： 主角： 主机一和主机二 过程：主机一向主机二发送请求连接的报文，由于网络环境差，致使此报文一直呆在网络环境中，最终导致失效，主机一或许早已完成连接，或许放弃了连接，反正此时不打算和主机二连接了，此时这个报文到达了主机二，主机二以为是主机一发的，假设只是两次握手，主机二向主机一发出确认报文问，但是主机一并没有打算连接，所以丢弃，但是主机二还以为连上了苦苦的在那里等，这就导致了资源的浪费。所以需要三次握手。 本人理解:一个面向连接的协议自然要保证连接的双向连通，两次握手，主机一知道了主机一到主机二的道路和主机二到主机一的道路都是通的，但是主机二只知道主机一到主机二的道路是通的，不知道主机二到主机一的道路是通的。除非主机一发送确认报文，并且主机二清楚的收到。（有点绕，可以多看几遍） 再来看看四次挥手： 主机一向主机二请求断开连接，代表着主机一并没有数据往主机二发了，但是不代表主机二没有数据往主机一发了，所以主机一你先别急，等主机二发完了，向主机一再发送请求断开连接，主机一再处理完主机二发来的剩余信息后才发送确认信息，然后主机一释放连接，主机二也释放连接。 5.2 常用的TCP参数Socket相当于TCP与UDP提供的接口，所以我们可以通过Socket获取或修改TCP的很多参数 ，这有利于我们构造更为实用的框架。 5.3 Close的恰当的时机在TCP参数中的LingerState能够尽量发完操作系统缓冲区的信息，但是不要忘了我们之前写的发送方法，我们在发送前会将消息放入自己设置的缓冲区，这些数据在关闭的时候就会丢失。 解决方法是设置一个bool值判断是否正在Closing，主动关闭的一方如果还有要发送的消息就将isClosing设置为true，关闭前就判断isClosing为true就不能关闭，如果为false就能发送。 5.4 心跳机制如果玩游戏一半，网线被噶了，那就没机会发送FIN信号了，如果不处理的话，服务端就一直占着系统资源，TCP有一个检测机制，如果在指定的时间没有数据传送就会发送一个信号，对端如果收到信号就会返回确认信号，如果一段时间没有收到回应就会重试几次，如果都没有，会认为网络不通关闭Socket。 启用方法： 但是TCP提供的方法不太适用于游戏，因为网游强调一个高实时性。 所以一般会自己实现心跳机制，客户端会定时向服务端发出PING消息，服务端收到回应PONG消息，若是很久没收到就说明连接不通，释放资源。 第六章 帧同步和状态同步6.1 状态同步状态同步指的是同步状态信息，比如角色需要做出的动作，角色的位置坐标、旋转发送给服务端，服务端再做广播。这种同步方式会将核心的逻辑判断交给服务端，否则就会导致延迟过高。举个例子： 如果服务端只是作为一个转发器，那么当一个玩家同步自己释放技能的状态，很有可能网络原因导致其他主机很晚才收到，这就会导致延迟很高，而如果只是将释放技能这个状态同步给服务端，服务端收到后进行一定程度的判断和运算再将处理后的状态同步给所有的玩家，这样再一定程度上保持了所有玩家是同步的，但是这也会导致响应慢等问题。所以状态同步一般不会适用于实时度比较高的pvp游戏。 6.1.1 跟随算法上述是服务端处理完再广播的方式，还有一种方法就是服务端还是当个转发工具人，网络不好的情况下势必会导致经常瞬移，所以聪明的程序大佬们想到了一个方法，就是如果获得了一个状态与客户端的状态有差距就以一定的速度将物体达到这个状态，只要同步频率够高误差就可以忽略，但是如果我们仔细分析一下，这个相对于直接状态同步误差更大，于是人们又引用了预测算法。 6.1.2 预测算法在某些有规律可循的条件下比如坦克的匀速运动，或者匀加速运动，我们可以预测坦克接下来的位置，我们就让坦克提前走到预测的位置去，但是这也会引发一个问题，就是玩家控制的东西一般来说没啥规律，所以如果玩家再运行途中停了下来，就会看到一个神奇的现象，一个往前开的坦克又默默的退了回来，而且预测算法也比较复杂。 两种算法各有优势，具体情况具体分析。 6.2 帧同步在游戏中同步的是玩家的操作指令，操作指令包含当前的帧索引。一般的流程是客户端上传操作到服务器， 服务器收到后并不计算游戏行为， 而是转发到所有客户端。帧同步其实是指令同步的一种。 6.2.1 指令同步玩家只同步指令信息，相同的输入 + 相同的时机 = 相同的输出。 6.2.2 同步帧帧同步的帧与unity中的帧是两个概念，在unity中我们说Update函数每一帧调用一次，我们也说Update调用的快慢取决于使用的设备，那如果某个设备Update慢点就没法保证相同的时机了，这些偏差会导致整个游戏不同的客户端差距巨大，所以我们会另外引入一个叫同步帧的概念。帧同步的特性导致客户端的逻辑实现和表现实现必须完全分离。Unity中的一些方法接口(如 Invoke， Update、动画系统等)是不可靠的，所有要自己实现一套物理引擎、数学库，做到逻辑和表现分离。 这样即使Unity的渲染是不同步的，但是逻辑跑出来是同步的。 6.3 帧同步与状态同步对比"},{"title":"Unity网络游戏开发(2)","date":"2022-11-16T07:23:53.000Z","url":"/2022/11/16/Unity%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/Unity%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91-2/","tags":[["网络游戏","/tags/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F/"],["unity","/tags/unity/"]],"categories":[["Unity网络游戏开发","/categories/Unity%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"]],"content":"Unity网络游戏开发第二部分 第四章 正确收发数据流第四章和第五章会涉及到一些TCP的一些机制 4.1 TCP数据流我们都听说过一句话TCP是一种流模式协议，UDP是一种数据报模式的协议。 TCP的流模式指的就是发送的数据如同水流一样发送方将数据发送出去时操作系统会将数据放在发送缓存中，然后接收方在接收前也会先将数据放入接收缓存中，而读取的速度取决于设备和操作系统，这也就意味着发送的次数与接收的次数并不一定相同。你发送的数据量不能大于对方的接收缓存（流量控制），如果你硬是要发送过量数据，则对方的缓存满了就会把多出的数据丢弃。 UDP和TCP不同，发送端调用了几次write，接收端必须用相同次数的read读完。UDP是基于报文的，在接收的时候，每次最多只能读取一个报文，报文和报文是不会合并的，如果缓冲区小于报文长度，则多出的部分会被丢弃。 4.2 粘包与半包基于TCP的流模式就会导致一个比较关键的问题，如果客户端在极短的时间内发送多个数据，就会导致接收的时候将两段代码合并在一起导致解析错误之类的问题。 我们看一下大乱斗游戏的一段代码。 这里我用了一个协程让程序等0.1秒之后再请求服务器上其他玩家的数据，为什么呢？我们把他改成连续发送会怎样呢？ 我们先看看协程方式下服务端收到的消息 再将程序改成连续发送 可以看到服务端将连续两次发的消息合成了一句消息，导致了服务端程序无法解析，导致程序报错并退出，如果正在运营的网游出现这种情况导致服务器停机，这样会造成很大的损失。 这个现象被称为粘包现象，那么半包现象也好理解了，运气较差的话操作系统将一半的指令读取了，这样也会给服务端造成比较那一处理的麻烦。 一般有三种方法可以解决粘包与半包问题： 4.2.1 长度信息法这个方法是在每个数据包前加上长度信息，比如传输hello就变成5hello，一个字节最多表示255个字节，稍微有点少，所以一般会选择Int16或者Int32来表示数据长度，这样再服务端处理的时候就可以先放进一个缓冲区，通过程序保证每一次都能拿到对应的发送信息。 4.2.2 固定长度法规定每条信息的长度，如果一条信息短于这个规定长度则用规定的字符将信息填充到这个固定长度，比如规定长度为10，我要发送hello，规定用.来补全，就变成了hello…..了。 4.2.3 结束符号法规定某个不会使用的符号作为结束符号，这样只需要检测到这个符号，就把这个符号之前的信息切出来，保证服务端接收的次数和客户端发送的次数一致。 书上采用的是长度信息法。 4.3 大端小端问题使用长度信息法的话我们需要将代表长度的Int16或者Int32转化成byte数组发送出去，到了接收方肯定需要再转化成Int类型这个时候会用到一下两个方法： 而这两句可能会导致大端小端问题 4.3.1 什么是大端小端学过计组的可能有了解，不同的CPU使用了不同的存储方式，这是由于一些历史的因素导致的。 大端：高地址存低字节，低地址存高字节 小端：低地址存低字节，高地址存高字节 例如： 这是一个16位的内存，我们将他转化位一个Int16类型的数 如果是个大端的系统那么高地址存低字节，高地址的00000010会转化为2，低地址的存高字节，低地址的00000001会转化成256，整个数据会转化为256+2=258。 如果是个小端的系统那么高地址存高字节，高地址的00000010会转化为512，低地址存低字节，低地址的00000001会转化成1，整个数据会转化成512+1=513。 所以同样的一串二进制数在不同的系统中会解析成不同的数字，非常的不方便。 4.3.2 如何解决大端小端的问题既然计算机本身不能解决问题，那么我们就用程序来解决问题，我们首先规定数据的传输必须使用小端输入，因为我们必须使用小端编码，所以我们需要判断系统是否是小端，如果不是小端，那么我们就使用Reverse函数来转化成小端模式。 一下是发送数据的大致代码 拓展: 虽然BitConverter.IsLittleEndian可以直接调用并判断计算机的大小端，但是我们也应该学习一下如何去实现判断大小端的方法，我分别用C#，C++，C三种语言实现一下： C++： C++使用了union的特点来测试：不懂union可以去查一下 C： C++完全兼容C，所以也可以用这种方法 拓展结束 发送端的代码搞定了，但是如果接收端是大端的话BitConverter.ToInt16也会出问题，所以我们要自己解析接收到的代码： 这段代码理解起来可能稍微有点难理解，首先我们先将第二个字节向左移动八位，也就是乘了一个256然后与第一个字节相与，这在二进制中代表的是相加。最后再强转成Int16类型的数值。 4.4 不完整发送之前介绍到TCP在发送时会先将需要发送的数据先放入操作系统的缓冲区，如果操作系统缓冲区设计的比较小，在网络环境较差的环境下，导致操作系统的缓冲区满了，这个时候再发送，溢出的部分会被抛弃掉引发不完整发送，虽然再网络通畅的环境下，Send只发送部分数据的改率不高，很多商业游戏都没有处理这种情况，但是我们要知道这种情况如何去处理。 4.4.1 解决方案要让数据能够完整发送，最好的方法就是将这个数据在发送前保存起来，如果发生不完整发送，在回调函数中继续发送数据。 代码实现： 解析以上这段代码，首先我们定义了自己的缓冲区，缓冲区偏移量，缓冲区的剩余长度。然后分别赋值，调用BeginSend，发送完成调用回调函数，将偏移量加上已发送数据，定位到发送到哪了，将剩下的长度减去发送的长度，用于判断是否发完，没发完继续调用BeginSend继续发送。 这种方法已经解决了大部分的问题，但是如果我们在还没来的及调用回调函数发出剩下的数据时又再次调用了Send，那么sendBytes，length，readIdx都会被重置，该发不完还是发不完（你这不是什么都没解决嘛），为此我们有必要牺牲一点点内存来构造一个加强版的缓冲区。我们将设计一个缓冲队列，每一次发送新的消息都将新消息写入队列的末尾，等前面的消息读取完，就将前面的消息弹出队列，开始读取后面的消息。 补充：如果你有过开发动作游戏的经验的话，你就会发现很多设计都有一曲同工之妙，比如你处理玩家的一系列指令的话，也可以将这些指令先放入一个队列，程序再一个一个调用。而且如果有什么特殊攻击的话也可以通过此判断。 我们来看看实现的代码： 队列我们直接使用Queue 看一下如何使用呢： ​ 这样的程序看似已经非常完善了，但是我们依旧忽略了一个问题，这是个异步方法，回调函数和BeginSend运行于不同的线程，不同的线程操作同一段内存一定要注意一个问题，那就是线程冲突，设想一种情况：我们先发一条消息，这个消息放进了队列，此时开始运行Send，这个时候Send函数又被调用，将另一条消息放入队列这个时候回调函数刚还执行完并将第一条消息发送出去，再次调用了BeginSend，将第二条消息发送出去了，原线程也在此时调用了BeginSend，于是一条消息发送了两次。 画个图理解以下 学过操作系统的都明白这中情况怎么处理，简单来说就是加锁： 4.5 高效接收数据既然要追求极致那就贯彻到底，接收数据我们也可以使用之前定义的ByteArray 首先我们要解决两个问题 1.能读写信息 2.缓冲区不够长时自动扩张缓冲区 那么我们就来完善以下ByteArray代码： 使用方法： 这里就不多做介绍了，具体的内容和实现可以多看看代码"},{"title":"Unity网络游戏开发(1)","date":"2022-11-16T06:19:47.000Z","url":"/2022/11/16/Unity%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/Unity%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91-1/","tags":[["网络游戏","/tags/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F/"],["unity","/tags/unity/"]],"categories":[["Unity网络游戏开发","/categories/Unity%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"]],"content":"近几年大量的网络游戏大热，相较于单机多了更多的趣味，且手游越来越火热，所以网络游戏开发势必成为一个客户端程序员的基本素养，不仅要了解客户端的搭建，还要熟悉服务端的基本实现方式。 本系列专栏作为Unity3D网络游戏实战的笔记总结 第一章 网络游戏的开端1.1 服务端一款网络游戏分为客户端服务端两个部分，客户端在用户设备上运行，服务端则在游戏运营商的服务器上运行。服务端与客户端之间通常使用TCP网络通信，各个服务端之间互相使用TCP连接，形成服务端集群。 1.2 Socket我们都知道计算机网络七层模型和五层模型，那在学习的时候常用的五层模型来说，分为物理层，数据链路层，网络层，传输层，应用层，我们也知道传输层实现端到端的通信主要的两个协议：TCP协议、UDP协议，这两个协议的区别与实现请自行去学习计算机网络这门课，我们今天要介绍的是Socket。可能有人和我当时有一样的疑问，这个Socket是应用层的还是传输层的，经过我的查阅，这个Socket应该和TCP、UDP一样属于传输层，我们可以把它理解为TCP、UDP协议的封装，以及对外提供的接口。 那么它其中都包含了什么呢？ ​ 1.协议（TCP，UDP） ​ 2.本地IP地址 ​ 3.本地端口 ​ 4.远程IP地址 ​ 5.远程端口 每一条Socket连接代表着：本地Socket→本地端口→网络介质→远程端口→远程Socket 的链路。 为了方便之后的使用，我们先了解一下Socket通信的完整流程（TCP协议） ​ 1.创建一个Socket对象（使用API Socket），绑定本地使用的端口，服务端一定要在程序中指定端口进行绑定（使用API Bind），而客户端在连接（使用API Connect）时会由系统分配端口，可以省去绑定步骤 ​ 2.服务端开启监听（使用API Listen），等待客户端接入 ​ 3.客户端连接服务器（使用API Connect） ​ 4.服务端接收连接（使用API Accept） ​ 5.客户端与服务端通过Send和Receive等API收发数据 ​ 6.某一方关闭连接（使用API Close），结束通信 第二章 异步API2.1 API如果使用上述API会因为是同步程序导致在网络环境稍差的情况下会造成客户端卡顿，所以同步API一般只用于早期测试，真正开发的时候会尽量使用异步API，虽然异步API不是那么容易理解，但是他能使客户端更加流畅。 而这些API基本都是上面描述的API前面加上Begin前缀，比如Connect的异步调用就是BeginConnect。 所有的异步API参数中都有一个委托，这个委托需要放入一个回调函数，以达到异步的效果。 2.2 非异步方式解决程序卡顿问题异步很好，而且在实际的游戏开发中也会更多的使用异步API来实现网络编程。 但是同时也有其他的一些API也能够达到类似的目的。也就是Poll、Select的API。 2.2.1 PollPoll的作用就是判断某个Socket是否可读可写可用，调用方式为 microSeconds：等待回应的时间，-1为一直等待，0表示不阻塞 mode： SelectMode.SelectRead：是否可读 SelectMode.SelectWrite：是否可写 SelectMode.SelectError：是否可用 Poll的服务端的核心代码为： Poll简单来说就是一个一个检测是否有可读信息，有就处理，这样就能避免明明没有可用的消息还是将程序阻塞在哪里，导致卡顿，但是由于没有数据的时候也还是需要检测数据，同样也还是浪费，且导致CPU占用率过高。 2.2.2 SelectSelect相对Poll来说实现了多路复用，即同时检测多个Socket状态，调用方式为： 前三个参数分别对应三个列表，第四个参数为等待回应时间 Select服务端的核心代码： Select与Poll其实很相近，只是Poll是一个一个处理，导致其频繁的调用造成CPU占用率高，但是Select集中去处理，调用次数少CPU占用率就会稍微低一点，但是两个方法都是使用一个死循环循环的去执行，在客户端中也是在Update函数里面不停检测，所以商业上为了达到性能的极致通常还是会选用异步。 第三章 大乱斗游戏本游戏的原代码 服务端 客户端"}]