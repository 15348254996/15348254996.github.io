[{"title":"C#知识(4)","date":"2022-12-24T15:29:32.000Z","url":"/2022/12/24/CS%E7%9F%A5%E8%AF%86/CS%E7%9F%A5%E8%AF%86-4/","tags":[["C#","/tags/C/"]],"categories":[["C#知识","/categories/C-%E7%9F%A5%E8%AF%86/"]],"content":"本节主要内容：委托相关知识 1.委托本来我是想先聊聊事件的，但是没有委托的事件是不完整的，所以我们还是先聊一下委托， 如果你和我一样是C++和C#双开的，你一定知道C++里面有一个概念叫做指针，而指针中有一类比较特殊的叫做函数指针，函数指针的作用其实就是让一个函数变成一个变量，让函数变成方法的参数，从而指定方法根据不同情况使用不同函数。 其实C#中委托和函数指针的作用几乎一模一样，，又或者说就是一样的。先来看一下用法吧。 委托的使用非常简单，声明的时候使用一个delegate关键词就行。使用的话可以把实例出来的委托名直接作为函数名使用。也可作为参数传给其他的方法。 接下来我们讨论以下委托的深层次的东西（来源于《clr via C#》） 使用起来简答的东西内部的实现细节就会越复杂，为了让委托好用，编译器和clr为我们干了太多事了（感动）（如果不知到clr是什么的，我回头会写，你可以先当它是C#虚拟机） 当我们用以下语句定义一个委托时 编译器会将这行代码定义成下面这样一个类 BeginInvoke和EndInvoke先不谈，先聊一下构造器和Invoke函数 构造器，其实就是C++的构造函数，我们首先注意到的是它的两个参数，既然构造函数有参数，自然是要用这些函数来初始化类中的成员的，所有的委托都是继承于System.MulticastDelegate这个类，而System.MulticastDelegate这个类又是派生自System.Delegate类，这其中有一些历史原因，这里就不展开说了，反正就是继承下来的成员有三个比较重要的： 所以构造器的两个参数分别是target，methodPtr。 最后一个字段invocationList则是在我们像allshow那样将一堆方法构造成一个委托链时会用到，他就像一个链表分别去装构造这个委托的所有方法或委托。 接下来是Invoke方法，这个方法在委托被定义的时候被定义,通过调用target和methodPtr字段在指定的对象上调用包装好的回调方法。所以通过委托调用方法时，其实就是在调用委托类的Invoke方法，所以你直接在编程的时候就直接写成a.Invoke(s)也可以。 最后就是在System.Delegate类中有个方法可以直接取得invocationList中的值。比如下面这个例子就是其中的一种用法。 "},{"title":"C#知识(3)","date":"2022-12-24T15:27:43.000Z","url":"/2022/12/24/CS%E7%9F%A5%E8%AF%86/CS%E7%9F%A5%E8%AF%86-3/","tags":[["C#","/tags/C/"]],"categories":[["C#知识","/categories/C-%E7%9F%A5%E8%AF%86/"]],"content":"本节主要内容：属性、成员和字段的区别，接口相关知识 1.属性、成员和字段的区别字段一般在类内部使用，所以一般是private属性。 属性一般是供外部访问，所以一般是public属性。 成员则是包括属性，字段，方法，事件等。 2.接口接口与其叫接口不如叫约束，他规定了一个东西是什么，而派生类则定义了怎么做 接口中可以声明属性（是属性，不是成员，也不是字段），方法和事件，接口只负责声明，定义由派生类实现。 接口的实现有两种方式，分别是隐式实现和显式实现 1.隐式实现接口的大部分实现都是靠隐式实现 2.显示实现显式实现是为了解决实现多个接口时有可能出现的重名问题。 为了解决重名的问题，需要使用到向上转型 3.接口其他细节 实现接口的任何类型或结构都必须实现器所有的成员 接口类似于只有抽象成员的抽象基类。 实现接口的任何类或结构都必须实现其所有成员。 接口无法直接进行实例化。 其成员由实现接口的任何类或结构来实现。 接口可以包含事件、索引器、方法和属性。 接口不包含方法的实现。 一个类或结构可以实现多个接口。 一个类可以继承一个基类，还可实现一个或多个接口。 "},{"title":"C#知识(2)","date":"2022-12-24T15:16:39.000Z","url":"/2022/12/24/CS%E7%9F%A5%E8%AF%86/CS%E7%9F%A5%E8%AF%86-2/","tags":[["C#","/tags/C/"]],"categories":[["C#知识","/categories/C-%E7%9F%A5%E8%AF%86/"]],"content":"本节主要内容：Partial关键字，结构体struct 1.partial关键字paritial 可以实现类的逻辑拆分到不同的文件。 上面的代码虽然是在不同的文件中，但是在同一个项目中同时定义了两个相同的名字是一定会报错的。 但是当我门使用partial关键字来限定类后则不会报错 运行输出结果： 2.结构体C#中的结构体的定义和C++别无二致，并且声明的方式也是相同的，都是类似与以下的代码： 但是我查了一些资料，发现这两个语言的结构体其实差距还是蛮大的 1.C++ struct首先是C++的结构体，C++的结构体和类几乎没有任何区别，他包含类有的所有特性，不仅能包含变量，也能继承，实现多态甚至类可以继承于结构体，结构体也能继承于类，说实话，我看到这的时候人都傻了，既然结构体和类这么像，为啥还要结构体，我认为是为了兼容c语言的语法吧。而在C++中结构体与类的主要区别就仅仅体现在两个方面： 1.默认的继承访问权限，结构体默认是public继承，class是private的。 2.成员变量的默认访问权限，结构体默认是public，class是private。 2.C# structC#的结构体也没有C的那么单纯，他也能带有方法字段，同时他还能带有索引、属性、运算符方法和事件，大概有以下特点： 结构可带有方法、字段、索引、属性、运算符方法和事件。 结构可定义构造函数，但不能定义析构函数。但是，您不能为结构定义无参构造函数。无参构造函数(默认)是自动定义的，且不能被改变。 与类不同，结构不能继承其他的结构或类。 结构不能作为其他结构或类的基础结构。 结构可实现一个或多个接口。 结构成员不能指定为 abstract、virtual 或 protected。 当您使用 New 操作符创建一个结构对象时，会调用适当的构造函数来创建结构。与类不同，结构可以不使用 New 操作符即可被实例化。 如果不使用 New 操作符，只有在所有的字段都被初始化之后，字段才被赋值，对象才被使用。 结构体中声明的字段，除非将字段声明为 const 或 static，否则无法赋予初值。 赋值时是深拷贝 在为属性器时，不能局部赋值（比如 transofrm.position.x 不能直接赋值） 结构体相比类，内存的回收效率更高，不容易产生 gc，所以需要频繁创建的数据对象建议用结构体来实现，比如 Unity 的 Vector3&#x2F;2 等。 还有一点需要提醒，C#结构体的默认访问权限是private 其次结构体作为值类型在栈上分配内存存储，至于如果在结构体内有引用类型，那栈中就保存这个引用类型分配在堆的地址，值类型在用完由clr回收机制自动回收，对于结构体中的引用类型，回收的时候只回收用于存储地址的内存，而用于存储引用类型成员变量值的内存，则等待回收机制进行回收。"},{"title":"C#知识(1)","date":"2022-12-24T12:52:38.000Z","url":"/2022/12/24/CS%E7%9F%A5%E8%AF%86/CS%E7%9F%A5%E8%AF%86-1/","tags":[["C#","/tags/C/"]],"categories":[["C#知识","/categories/C-%E7%9F%A5%E8%AF%86/"]],"content":"本节主要内容：引用类型与值类型，程序集和类的访问权限，internal。 1.引用类型、值类型C#中有两种类型：分别是引用类型和值类型 在C#中值类型的变量直接存储数据，而引用类型的变量持有的是数据的引用，数据存储在数据堆中。 图上忘写了，数组也是引用类型 这里顺便提一下C++和C#在内存管理上的区别，C#是一种托管语言，它的垃圾回收机制时由.net平台负责，但是我们还是有必要了解这方面的。 先是**C#**，程序运行时可能会有多个线程，每个线程在创建时都会生成一个线程栈，值类型的值会直接在线程栈上进行存储，而引用类型的值则会先在堆上开辟一块空间，在栈上存储这块控件的地址 然后是C++,C++编译程序占用内存分为以下几个部分， 1.栈区（stack）：— 由编译器自动分配释放 ，存放函数参数值，局部变量值等。其操作方式类似于数据结构中栈。 2.堆区（heap）：一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中堆是两回事，分配方式类似于链表。 3.全局区（静态区）：全局变量和静态变量存储是放在一块，初始化全局变量和静态变量在一块区域， 未初始化全局变量和未初始化静态变量在相邻另一块区域。 程序结束后由系统释放。 4.文字常量区 —常量字符串就是放在这里。 程序结束后由系统释放 5.程序代码区—存放函数体二进制代码。 栈上的内存自动分配了，暂且不聊，这个堆区则是由程序员来分配释放的，C的话是使用malloc分配，free释放，C++则是用new和delete。 重要：值类型在内存管理方面具有更好的效率，并且不支持多态，适合用做存储数据的载体；引用类型支持多态，适合用于定义应用程序的行为。 值得注意的是，引用类型和值类型都继承自System.Object类。不同的是，几乎所有的引用类型都直接从System.Object继承，而值类型则继承其子类，即直接继承System.ValueType。即System.ValueType本身是一个类类型，而不是值类型。其关键在于ValueType重写了Equals()方法，从而对值类型按照实例的值来比较，而不是引用地址来比较。 2.程序集和类的访问权限internal程序集是一个或多个类型的一文件及资源文件的集合（感觉和文件夹差不多）。 Microsoft引入这个概念的目的是可以将代码分成多个文件，如果客户端永远使用不到这多程序可以永远不将这段程序加载到客户端上。 然后internal这个类访问权限以前我也完全没听说过，也是最近在看《clr via C#》这本书才了解到这个访问权限，它所修饰的类只能在同一个程序集中被访问，而同一个程序集表示同一个dll程序集或同一个exe程序集。 有人可能会注意到dll这个词，当时我读到这也挺疑惑的，因为我之前曾经读过《深入理解计算机系统》，这书提到过动态链接库这样一个概念，而动态链接库在windows中的后缀也是dll。 接下来演示以下unity中如何使用程序集 首先先说明一下使用程序集在unity的优点吧。 1.提高编译速度：unity将用户定义的C#文件默认放进Assembly-Csharp.dll程序集中，每当编写或修改完代码时，unity需要编译整个程序集的代码，来判断是否编译错误。使用多个程序集就能解决这个问题。 2.减少项目的耦合度：不用多解释，和设计模式思路一样，而且可以快速判断代码出在哪一个程序集中的文件。通过程序集的依赖，来联系各个程序集。 方法： 1.在一个空的文件夹中右键，选择Create，选择Assembly Definition，在再这个文件夹中创建的文件将自动划入创建的程序集中 2.在程序集的inspector面板上的Assembly Definition References添加需要依赖的类，则可以完成程序集的依赖设置。 "},{"title":"Unity网络游戏开发(3)","date":"2022-11-16T07:38:12.000Z","url":"/2022/11/16/Unity%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/Unity%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91-3/","tags":[["网络游戏","/tags/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F/"],["unity","/tags/unity/"]],"categories":[["Unity网络游戏开发","/categories/Unity%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"]],"content":"Unity网络游戏开发第三部分 第五章 深入了解TCP5.1 TCP的连接、传输和终止我们都听说过三次握手，四次挥手的表述，但是很难理解为什么要三次握手四次挥手。 要理解这点，我们首先要理解到TCP是一种面向连接的，可靠的，基于字节流的传输层协议，像连接这种事为了确保可靠一定要保证双方的网络是相通的。 先来看三次握手： 主角： 主机一和主机二 过程：主机一向主机二发送请求连接的报文，由于网络环境差，致使此报文一直呆在网络环境中，最终导致失效，主机一或许早已完成连接，或许放弃了连接，反正此时不打算和主机二连接了，此时这个报文到达了主机二，主机二以为是主机一发的，假设只是两次握手，主机二向主机一发出确认报文问，但是主机一并没有打算连接，所以丢弃，但是主机二还以为连上了苦苦的在那里等，这就导致了资源的浪费。所以需要三次握手。 本人理解:一个面向连接的协议自然要保证连接的双向连通，两次握手，主机一知道了主机一到主机二的道路和主机二到主机一的道路都是通的，但是主机二只知道主机一到主机二的道路是通的，不知道主机二到主机一的道路是通的。除非主机一发送确认报文，并且主机二清楚的收到。（有点绕，可以多看几遍） 再来看看四次挥手： 主机一向主机二请求断开连接，代表着主机一并没有数据往主机二发了，但是不代表主机二没有数据往主机一发了，所以主机一你先别急，等主机二发完了，向主机一再发送请求断开连接，主机一再处理完主机二发来的剩余信息后才发送确认信息，然后主机一释放连接，主机二也释放连接。 5.2 常用的TCP参数Socket相当于TCP与UDP提供的接口，所以我们可以通过Socket获取或修改TCP的很多参数 ，这有利于我们构造更为实用的框架。 5.3 Close的恰当的时机在TCP参数中的LingerState能够尽量发完操作系统缓冲区的信息，但是不要忘了我们之前写的发送方法，我们在发送前会将消息放入自己设置的缓冲区，这些数据在关闭的时候就会丢失。 解决方法是设置一个bool值判断是否正在Closing，主动关闭的一方如果还有要发送的消息就将isClosing设置为true，关闭前就判断isClosing为true就不能关闭，如果为false就能发送。 5.4 心跳机制如果玩游戏一半，网线被噶了，那就没机会发送FIN信号了，如果不处理的话，服务端就一直占着系统资源，TCP有一个检测机制，如果在指定的时间没有数据传送就会发送一个信号，对端如果收到信号就会返回确认信号，如果一段时间没有收到回应就会重试几次，如果都没有，会认为网络不通关闭Socket。 启用方法： 但是TCP提供的方法不太适用于游戏，因为网游强调一个高实时性。 所以一般会自己实现心跳机制，客户端会定时向服务端发出PING消息，服务端收到回应PONG消息，若是很久没收到就说明连接不通，释放资源。 第六章 帧同步和状态同步6.1 状态同步状态同步指的是同步状态信息，比如角色需要做出的动作，角色的位置坐标、旋转发送给服务端，服务端再做广播。这种同步方式会将核心的逻辑判断交给服务端，否则就会导致延迟过高。举个例子： 如果服务端只是作为一个转发器，那么当一个玩家同步自己释放技能的状态，很有可能网络原因导致其他主机很晚才收到，这就会导致延迟很高，而如果只是将释放技能这个状态同步给服务端，服务端收到后进行一定程度的判断和运算再将处理后的状态同步给所有的玩家，这样再一定程度上保持了所有玩家是同步的，但是这也会导致响应慢等问题。所以状态同步一般不会适用于实时度比较高的pvp游戏。 6.1.1 跟随算法上述是服务端处理完再广播的方式，还有一种方法就是服务端还是当个转发工具人，网络不好的情况下势必会导致经常瞬移，所以聪明的程序大佬们想到了一个方法，就是如果获得了一个状态与客户端的状态有差距就以一定的速度将物体达到这个状态，只要同步频率够高误差就可以忽略，但是如果我们仔细分析一下，这个相对于直接状态同步误差更大，于是人们又引用了预测算法。 6.1.2 预测算法在某些有规律可循的条件下比如坦克的匀速运动，或者匀加速运动，我们可以预测坦克接下来的位置，我们就让坦克提前走到预测的位置去，但是这也会引发一个问题，就是玩家控制的东西一般来说没啥规律，所以如果玩家再运行途中停了下来，就会看到一个神奇的现象，一个往前开的坦克又默默的退了回来，而且预测算法也比较复杂。 两种算法各有优势，具体情况具体分析。 6.2 帧同步在游戏中同步的是玩家的操作指令，操作指令包含当前的帧索引。一般的流程是客户端上传操作到服务器， 服务器收到后并不计算游戏行为， 而是转发到所有客户端。帧同步其实是指令同步的一种。 6.2.1 指令同步玩家只同步指令信息，相同的输入 + 相同的时机 &#x3D; 相同的输出。 6.2.2 同步帧帧同步的帧与unity中的帧是两个概念，在unity中我们说Update函数每一帧调用一次，我们也说Update调用的快慢取决于使用的设备，那如果某个设备Update慢点就没法保证相同的时机了，这些偏差会导致整个游戏不同的客户端差距巨大，所以我们会另外引入一个叫同步帧的概念。帧同步的特性导致客户端的逻辑实现和表现实现必须完全分离。Unity中的一些方法接口(如 Invoke， Update、动画系统等)是不可靠的，所有要自己实现一套物理引擎、数学库，做到逻辑和表现分离。 这样即使Unity的渲染是不同步的，但是逻辑跑出来是同步的。 6.3 帧同步与状态同步对比"},{"title":"Unity网络游戏开发(2)","date":"2022-11-16T07:23:53.000Z","url":"/2022/11/16/Unity%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/Unity%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91-2/","tags":[["网络游戏","/tags/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F/"],["unity","/tags/unity/"]],"categories":[["Unity网络游戏开发","/categories/Unity%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"]],"content":"Unity网络游戏开发第二部分 第四章 正确收发数据流第四章和第五章会涉及到一些TCP的一些机制 4.1 TCP数据流我们都听说过一句话TCP是一种流模式协议，UDP是一种数据报模式的协议。 TCP的流模式指的就是发送的数据如同水流一样发送方将数据发送出去时操作系统会将数据放在发送缓存中，然后接收方在接收前也会先将数据放入接收缓存中，而读取的速度取决于设备和操作系统，这也就意味着发送的次数与接收的次数并不一定相同。你发送的数据量不能大于对方的接收缓存（流量控制），如果你硬是要发送过量数据，则对方的缓存满了就会把多出的数据丢弃。 UDP和TCP不同，发送端调用了几次write，接收端必须用相同次数的read读完。UDP是基于报文的，在接收的时候，每次最多只能读取一个报文，报文和报文是不会合并的，如果缓冲区小于报文长度，则多出的部分会被丢弃。 4.2 粘包与半包基于TCP的流模式就会导致一个比较关键的问题，如果客户端在极短的时间内发送多个数据，就会导致接收的时候将两段代码合并在一起导致解析错误之类的问题。 我们看一下大乱斗游戏的一段代码。 这里我用了一个协程让程序等0.1秒之后再请求服务器上其他玩家的数据，为什么呢？我们把他改成连续发送会怎样呢？ 我们先看看协程方式下服务端收到的消息 再将程序改成连续发送 可以看到服务端将连续两次发的消息合成了一句消息，导致了服务端程序无法解析，导致程序报错并退出，如果正在运营的网游出现这种情况导致服务器停机，这样会造成很大的损失。 这个现象被称为粘包现象，那么半包现象也好理解了，运气较差的话操作系统将一半的指令读取了，这样也会给服务端造成比较那一处理的麻烦。 一般有三种方法可以解决粘包与半包问题： 4.2.1 长度信息法这个方法是在每个数据包前加上长度信息，比如传输hello就变成5hello，一个字节最多表示255个字节，稍微有点少，所以一般会选择Int16或者Int32来表示数据长度，这样再服务端处理的时候就可以先放进一个缓冲区，通过程序保证每一次都能拿到对应的发送信息。 4.2.2 固定长度法规定每条信息的长度，如果一条信息短于这个规定长度则用规定的字符将信息填充到这个固定长度，比如规定长度为10，我要发送hello，规定用.来补全，就变成了hello…..了。 4.2.3 结束符号法规定某个不会使用的符号作为结束符号，这样只需要检测到这个符号，就把这个符号之前的信息切出来，保证服务端接收的次数和客户端发送的次数一致。 书上采用的是长度信息法。 4.3 大端小端问题使用长度信息法的话我们需要将代表长度的Int16或者Int32转化成byte数组发送出去，到了接收方肯定需要再转化成Int类型这个时候会用到一下两个方法： 而这两句可能会导致大端小端问题 4.3.1 什么是大端小端学过计组的可能有了解，不同的CPU使用了不同的存储方式，这是由于一些历史的因素导致的。 大端：高地址存低字节，低地址存高字节 小端：低地址存低字节，高地址存高字节 例如： 这是一个16位的内存，我们将他转化位一个Int16类型的数 如果是个大端的系统那么高地址存低字节，高地址的00000010会转化为2，低地址的存高字节，低地址的00000001会转化成256，整个数据会转化为256+2&#x3D;258。 如果是个小端的系统那么高地址存高字节，高地址的00000010会转化为512，低地址存低字节，低地址的00000001会转化成1，整个数据会转化成512+1&#x3D;513。 所以同样的一串二进制数在不同的系统中会解析成不同的数字，非常的不方便。 4.3.2 如何解决大端小端的问题既然计算机本身不能解决问题，那么我们就用程序来解决问题，我们首先规定数据的传输必须使用小端输入，因为我们必须使用小端编码，所以我们需要判断系统是否是小端，如果不是小端，那么我们就使用Reverse函数来转化成小端模式。 一下是发送数据的大致代码 拓展: 虽然BitConverter.IsLittleEndian可以直接调用并判断计算机的大小端，但是我们也应该学习一下如何去实现判断大小端的方法，我分别用C#，C++，C三种语言实现一下： C++： C++使用了union的特点来测试：不懂union可以去查一下 C： C++完全兼容C，所以也可以用这种方法 拓展结束 发送端的代码搞定了，但是如果接收端是大端的话BitConverter.ToInt16也会出问题，所以我们要自己解析接收到的代码： 这段代码理解起来可能稍微有点难理解，首先我们先将第二个字节向左移动八位，也就是乘了一个256然后与第一个字节相与，这在二进制中代表的是相加。最后再强转成Int16类型的数值。 4.4 不完整发送之前介绍到TCP在发送时会先将需要发送的数据先放入操作系统的缓冲区，如果操作系统缓冲区设计的比较小，在网络环境较差的环境下，导致操作系统的缓冲区满了，这个时候再发送，溢出的部分会被抛弃掉引发不完整发送，虽然再网络通畅的环境下，Send只发送部分数据的改率不高，很多商业游戏都没有处理这种情况，但是我们要知道这种情况如何去处理。 4.4.1 解决方案要让数据能够完整发送，最好的方法就是将这个数据在发送前保存起来，如果发生不完整发送，在回调函数中继续发送数据。 代码实现： 解析以上这段代码，首先我们定义了自己的缓冲区，缓冲区偏移量，缓冲区的剩余长度。然后分别赋值，调用BeginSend，发送完成调用回调函数，将偏移量加上已发送数据，定位到发送到哪了，将剩下的长度减去发送的长度，用于判断是否发完，没发完继续调用BeginSend继续发送。 这种方法已经解决了大部分的问题，但是如果我们在还没来的及调用回调函数发出剩下的数据时又再次调用了Send，那么sendBytes，length，readIdx都会被重置，该发不完还是发不完（你这不是什么都没解决嘛），为此我们有必要牺牲一点点内存来构造一个加强版的缓冲区。我们将设计一个缓冲队列，每一次发送新的消息都将新消息写入队列的末尾，等前面的消息读取完，就将前面的消息弹出队列，开始读取后面的消息。 补充：如果你有过开发动作游戏的经验的话，你就会发现很多设计都有一曲同工之妙，比如你处理玩家的一系列指令的话，也可以将这些指令先放入一个队列，程序再一个一个调用。而且如果有什么特殊攻击的话也可以通过此判断。 我们来看看实现的代码： 队列我们直接使用Queue 看一下如何使用呢： ​ 这样的程序看似已经非常完善了，但是我们依旧忽略了一个问题，这是个异步方法，回调函数和BeginSend运行于不同的线程，不同的线程操作同一段内存一定要注意一个问题，那就是线程冲突，设想一种情况：我们先发一条消息，这个消息放进了队列，此时开始运行Send，这个时候Send函数又被调用，将另一条消息放入队列这个时候回调函数刚还执行完并将第一条消息发送出去，再次调用了BeginSend，将第二条消息发送出去了，原线程也在此时调用了BeginSend，于是一条消息发送了两次。 画个图理解以下 学过操作系统的都明白这中情况怎么处理，简单来说就是加锁： 4.5 高效接收数据既然要追求极致那就贯彻到底，接收数据我们也可以使用之前定义的ByteArray 首先我们要解决两个问题 1.能读写信息 2.缓冲区不够长时自动扩张缓冲区 那么我们就来完善以下ByteArray代码： 使用方法： 这里就不多做介绍了，具体的内容和实现可以多看看代码"},{"title":"Unity网络游戏开发(1)","date":"2022-11-16T06:19:47.000Z","url":"/2022/11/16/Unity%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/Unity%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91-1/","tags":[["网络游戏","/tags/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F/"],["unity","/tags/unity/"]],"categories":[["Unity网络游戏开发","/categories/Unity%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"]],"content":"近几年大量的网络游戏大热，相较于单机多了更多的趣味，且手游越来越火热，所以网络游戏开发势必成为一个客户端程序员的基本素养，不仅要了解客户端的搭建，还要熟悉服务端的基本实现方式。 本系列专栏作为Unity3D网络游戏实战的笔记总结 第一章 网络游戏的开端1.1 服务端一款网络游戏分为客户端服务端两个部分，客户端在用户设备上运行，服务端则在游戏运营商的服务器上运行。服务端与客户端之间通常使用TCP网络通信，各个服务端之间互相使用TCP连接，形成服务端集群。 1.2 Socket我们都知道计算机网络七层模型和五层模型，那在学习的时候常用的五层模型来说，分为物理层，数据链路层，网络层，传输层，应用层，我们也知道传输层实现端到端的通信主要的两个协议：TCP协议、UDP协议，这两个协议的区别与实现请自行去学习计算机网络这门课，我们今天要介绍的是Socket。可能有人和我当时有一样的疑问，这个Socket是应用层的还是传输层的，经过我的查阅，这个Socket应该和TCP、UDP一样属于传输层，我们可以把它理解为TCP、UDP协议的封装，以及对外提供的接口。 那么它其中都包含了什么呢？ ​ 1.协议（TCP，UDP） ​ 2.本地IP地址 ​ 3.本地端口 ​ 4.远程IP地址 ​ 5.远程端口 每一条Socket连接代表着：本地Socket→本地端口→网络介质→远程端口→远程Socket 的链路。 为了方便之后的使用，我们先了解一下Socket通信的完整流程（TCP协议） ​ 1.创建一个Socket对象（使用API Socket），绑定本地使用的端口，服务端一定要在程序中指定端口进行绑定（使用API Bind），而客户端在连接（使用API Connect）时会由系统分配端口，可以省去绑定步骤 ​ 2.服务端开启监听（使用API Listen），等待客户端接入 ​ 3.客户端连接服务器（使用API Connect） ​ 4.服务端接收连接（使用API Accept） ​ 5.客户端与服务端通过Send和Receive等API收发数据 ​ 6.某一方关闭连接（使用API Close），结束通信 第二章 异步API2.1 API如果使用上述API会因为是同步程序导致在网络环境稍差的情况下会造成客户端卡顿，所以同步API一般只用于早期测试，真正开发的时候会尽量使用异步API，虽然异步API不是那么容易理解，但是他能使客户端更加流畅。 而这些API基本都是上面描述的API前面加上Begin前缀，比如Connect的异步调用就是BeginConnect。 所有的异步API参数中都有一个委托，这个委托需要放入一个回调函数，以达到异步的效果。 2.2 非异步方式解决程序卡顿问题异步很好，而且在实际的游戏开发中也会更多的使用异步API来实现网络编程。 但是同时也有其他的一些API也能够达到类似的目的。也就是Poll、Select的API。 2.2.1 PollPoll的作用就是判断某个Socket是否可读可写可用，调用方式为 microSeconds：等待回应的时间，-1为一直等待，0表示不阻塞 mode： SelectMode.SelectRead：是否可读 SelectMode.SelectWrite：是否可写 SelectMode.SelectError：是否可用 Poll的服务端的核心代码为： Poll简单来说就是一个一个检测是否有可读信息，有就处理，这样就能避免明明没有可用的消息还是将程序阻塞在哪里，导致卡顿，但是由于没有数据的时候也还是需要检测数据，同样也还是浪费，且导致CPU占用率过高。 2.2.2 SelectSelect相对Poll来说实现了多路复用，即同时检测多个Socket状态，调用方式为： 前三个参数分别对应三个列表，第四个参数为等待回应时间 Select服务端的核心代码： Select与Poll其实很相近，只是Poll是一个一个处理，导致其频繁的调用造成CPU占用率高，但是Select集中去处理，调用次数少CPU占用率就会稍微低一点，但是两个方法都是使用一个死循环循环的去执行，在客户端中也是在Update函数里面不停检测，所以商业上为了达到性能的极致通常还是会选用异步。 第三章 大乱斗游戏本游戏的原代码 服务端 客户端"}]